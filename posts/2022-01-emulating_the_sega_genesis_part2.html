<!DOCTYPE html>
<html>
<head>
    <title>Emulating the Sega Genesis - Part II</title>

    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="description" content="transistorfet's website" />
    <meta name="author" content="transistor fet" />
    <meta name="keywords" content="jabberwocky, transistorfet, programming, electronics, rust, m68k, z80, sega, genesis, megadrive, trs80, emulator" />

    <link rel="canonical" href="https://jabberwocky.ca/posts/2022-01-emulating_the_sega_genesis_part2.html" />

    <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Recursive" type="text/css" charset="utf-8" />
    <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=IBM+Plex+Mono" type="text/css" charset="utf-8" />
    <link rel="stylesheet" href="../assets/normalize.css" type="text/css" charset="utf-8" />
    <link rel="stylesheet" href="../assets/layout.css" type="text/css" charset="utf-8" />
    <link id="pagetheme" rel="stylesheet" href="../assets/theme-light.css" type="text/css" charset="utf-8" />
    <link id="codetheme" rel="stylesheet" href="../assets/code-default.css" type="text/css" charset="utf-8" />
    <script src="../assets/theme.js"></script>
</head>
<body>
<div id="main">

    <div id="theme-toggle"></div>

    <div id="menu-toggle">&#x2630;</div>
    <input class="toggle-trigger" type="checkbox" checked />
    <div id="sidebar" class="toggle">
        <a href="../"><h2>Projects</h2></a>
        <hr>

<ul class="projects">
<li><a href="../projects/computie/">Computie 68k</a></li>
<li><a href="../projects/molten/">Molten</a></li>
<li><a href="../projects/moa/">Moa Emulator</a></li>
<li><a href="../projects/ruxpin/">Ruxpin OS</a></li>
<li><a href="../projects/fidget/">Fidget</a></li>
<li><a href="../projects/z280/">Z280 Computer</a></li>
<li><a href="../projects/gloworm/">Gloworm OS</a></li>
<li><a href="../projects/nerve/">Nerve Control Network</a></li>
<li><a href="../projects/deskclock2/">DeskClock2</a></li>
<li><a href="../projects/rgbnode/">RGB Node</a></li>
<li><a href="../projects/rgbnode-rs/">RGB Node with Rust</a></li>
<li><a href="../projects/webmush/">WebMUSH</a></li>
<li><a href="../projects/conlog/">Conlog</a></li>
<li><a href="../projects/fallingrust/">Falling Rust</a></li>
<li><a href="../projects/abugslife/">A Bug's Life</a></li>
<li><a href="../projects/acamlslife/">A Caml's Life</a></li>
<li><a href="../projects/synthetik/">Synthetik Synth</a></li>
<li><a href="../projects/meteorman/">Meteor Games</a></li>
<li><a href="../projects/logarithm/">Logarithm IRC Bot</a></li>
<li><a href="../projects/sdm/">Super Duper Moo</a></li>
<li><a href="../projects/sdrl/">SDRL Interpreter</a></li>
<li><a href="../projects/stutter/">Stutter IRC Client</a></li>
</ul>
<hr>
<h3>Posts</h3>
<ul class="posts">
<li><a href="../posts/2022-01-emulating_the_sega_genesis_part3.html">Emulating the Sega Genesis - Part III</a></li>
<li><a href="../posts/2022-01-emulating_the_sega_genesis_part2.html">Emulating the Sega Genesis - Part II</a></li>
<li><a href="../posts/2022-01-emulating_the_sega_genesis_part1.html">Emulating the Sega Genesis - Part I</a></li>
<li><a href="../posts/2021-11-making_an_emulator.html">Making a 68000 Emulator in Rust</a></li>
<li><a href="../posts/2021-09-bootstrapping_with_arduino.html">Bootstrapping a Homebuilt Computer Using An Arduino</a></li>
<li><a href="../posts/2021-08-molten_overview.html">An Overview Of Molten Internals</a></li>
</ul>


        <hr>
        <a href="https://github.com/transistorfet"><img class="icon" src="../assets/icons/github.svg"></a>
        <a href="https://bsky.app/profile/transistorfet.bsky.social"><img class="icon" src="../assets/icons/bluesky.svg"></a>
        <a href="https://mastodon.social/@transistor_fet"><img class="icon" src="../assets/icons/mastodon.svg"></a>
        <a href="https://twitch.tv/transistorfet"><img class="icon" src="../assets/icons/twitch.svg"></a>
        <a href="https://twitter.com/transistorfet"><img class="icon" src="../assets/icons/twitter.svg"></a>
        <a href="https://dev.to/transistorfet"><img class="icon" src="../assets/icons/dev-badge.svg"></a>
        <a href="mailto:trans@jabberwocky.ca"><img class="icon" src="../assets/icons/email.svg"></a>
        <a href="https://linkedin.com/in/sarimcfarland"><img class="icon" src="../assets/icons/linkedin.svg"></a>
    </div>
    <div id="content">

<h1 id="emulating-the-sega-genesis-part-ii">Emulating the Sega Genesis - Part II</h1>
<p><em>Also available on <a href="https://dev.to/transistorfet/emulating-the-sega-genesis-part-ii-16k7">dev.to</a></em></p>
<h6 id="written-december-2021january-2022-by-transistor_fet"><em>Written December 2021/January 2022 by transistor_fet</em></h6>
<p>A few months ago, I wrote a 68000 emulator in Rust named
<a href="https://jabberwocky.ca/projects/moa/">Moa</a>.  My original goal was to emulate a simple
<a href="https://jabberwocky.ca/projects/computie/">computer</a> I had previously built.  After only a few
weeks, I had that software up and running in the emulator, and my attention turned to what other
platforms with 68000s I could try emulating.  My thoughts quickly turned to the Sega Genesis and
without thinking about it too much, I dove right in.  What started as an unserious half-thought of
"wouldn't that be cool" turned into a few months of fighting documentation, game programming hacks,
and my sanity with some side quests along the way, all in the name of finding and squashing bugs in
the 68k emulator I had already written.</p>
<p>This is Part II in the series.  If you haven't already read <a href="https://jabberwocky.ca/posts/2022-01-emulating_the_sega_genesis_part1.html">Part
I</a>, you might want to do
so.  It covers setting up the emulator, getting some game ROMs to run, and implementing the DMA and
memory features of the VDP.  Part II covers adding a graphical frontend to Moa, and then
implementing a first attempt at generating video output.  <a href="https://jabberwocky.ca/posts/2022-01-emulating_the_sega_genesis_part3.html">Part
III</a> will be about
debugging the various problems in the VDP and CPU implementations to get a working emulator capable
of playing games.  For more detail on the 68000 and the basic design of Moa, check out <a href="https://jabberwocky.ca/posts/2021-11-making_an_emulator.html">Making a
68000 Emulator in Rust</a>.</p>
<ul>
<li><a href="#previously">Previously</a></li>
<li><a href="#choosing-a-graphics-crate">Choosing A Graphics Crate</a></li>
<li><a href="#abstracting-out-the-frontend">Abstracting Out The Frontend</a></li>
<li><a href="#updating-windows">Updating Windows</a></li>
<li><a href="#the-vdp-device">The VDP Device</a></li>
<li><a href="#colours-and-patterns">Colours And Patterns</a></li>
<li><a href="#scrolls-and-sprites">Scrolls And Sprites</a></li>
<li><a href="#next-time">Next Time</a></li>
</ul>
<h2 id="previously">Previously</h2>
<p>In less than a week, I had taken my 68000 emulator, plugged some Sega Genesis ROMs into it, written
some boilerplate devices, and implemented the memory and DMA operations of the Genesis' video
display processor (VDP).  I could watch the log messages produced by the emulator as the ROMs were
being interpreted instruction by instruction, reading the controller data, writing to the VDP, and
generally doing things.  (Doing what?  I didn't quite know yet).</p>
<p>The CPU interface to the VDP was pretty much done, so the next thing to work on was actually
displaying output.  The data, which is already loaded into VRAM, CRAM, and VSRAM, as well as the
internal VDP registers, needs to be turned into pictures.  While the real hardware would generate a
CRT video signal which would directly control a CRT-based television, the emulator will generate a
single frame of video at a time, stored in a buffer, and display that buffer in a local window on
the host computer.  Do this fast enough and I'll have video.</p>
<h2 id="choosing-a-graphics-crate">Choosing A Graphics Crate</h2>
<p>Before I could implement the display output, I needed something to draw the images onto.  There are
quite a few Rust crates available to create a GUI window and update it with 2D graphics.  Most of
these are of course intended for making games, and also include ways of getting key presses as
input, which I'll also need.  I looked at <a href="https://www.piston.rs">Piston</a>, which I've used before on
other projects, <a href="https://macroquad.rs/">Macroquad</a>, which also supports web assembly as well as
desktop targets, <a href="https://github.com/parasyte/pixels">Pixels</a>, which is intended specifically for 2D
games, and <a href="https://github.com/emoon/rust_minifb">Minifb</a>, which is also specifically for 2D
applications, but is much simpler.  I also tried out
<a href="https://github.com/koute/libretro-backend">libretro</a>, which is specifically made for video game
emulation, but I found it much more restrictive than the others because of it's narrow focus.</p>
<p>Initially I had wanted to run the simulation in another thread so that I could run it the same way I
had been for emulating Computie, but most of these libraries are set up to use a single thread and
single main loop where everything happens in-line with the screen updating and input reading.  For a
typical video game, the gameplay and any frame updating would be done just before submitting the
frame buffer to the library to be drawn to the screen, and then the library would block until the
next frame is needed.</p>
<p>In order to run it inline with the update loop, I added a function to <code>System</code> to only run the step
functions for a given amount of simulated time before returning, which would allow the simulation to
proceed far enough for the next frame to be updated before the loop updates the GUI window.  Even
though there is no specific coordination between when the frame is updated vs how much simulated
time has passed, it still works surprisingly well.  That said I'm still concerned with the fact that
the emulator is not cycle-accurate yet, so the simulated time is not accurate either.  Having the
option of running it in another thread would allow me to use other means of coordinating the
simulation with the real clock, and would give me more options when I implement other platforms.
This was a major factor in choosing a library.</p>
<p>Piston is feature rich, and it's modular design allows it to be tailored for any given use, but it's
a bit more than I need for this project.  It includes all sorts of drawing primitives for 2D
graphics, but what I really want is to just draw individual pixels to a buffer, or update the entire
screen at once from a pre-drawn buffer.  The size of the compiled binary using Piston was over 100MB
too, with Pixels coming in a close second in size.</p>
<p>Pixels was also a bit more than I needed.  It's based on <code>wgpu</code> which supports all sorts of GPU
features like shading, but I don't need any of that since the Genesis will only generate raw pixel
data, so the extra features just make it more complicated than it needs to be.</p>
<p>Macroquad is much lighter, by comparison, but because it can run in a web browser, it has some
restrictions on how the updating can be done.  It uses an <code>async</code> main function because in
WebAssembly, the main loop cannot block like a normal loop without inhibiting other background code.
It would be neat to run Moa in web assembly, but porting it to run in web assembly could be a lot of
work that I don't intend to do any time soon, and since Macroquad wont easily support the threaded
mode, I'll leave it as a possible secondary frontend for a later date.</p>
<p>Libretro has a similar restriction in that you give it a function to be called each time a frame is
needed, and the simulation would have to be run in that time.  However it also supplies its own main
function and update loop, and control is only passed to the specific machine emulator when a game is
loaded (which is also handled by the library) or when the next frame of data is needed.  It might be
fine for a single-purpose video game emulator but it really doesn't fit with my hope for a more
general simulation platform, so this definitely isn't a good choice as my primary frontend.</p>
<p>That left Minifb, which turned out to be the best fit.  It's very simple without a lot of features.
You create a window (just one function call), a frame buffer to fill the window, and a main loop
which just has to call a function to update the frame buffer to the screen.  An optional frame
limiter can be used, which causes the update function to block until the next frame is needed, but
the simulation can be run on a separate thread too.  Input can be read during the main loop, and the
main loop is implemented entirely in the application-side, so it's a bit more flexible without being
complicated for my needs.  The compiled binary comes in at only 5 or 6 MB as well, which nice.</p>
<h2 id="abstracting-out-the-frontend">Abstracting Out The Frontend</h2>
<p>As usual, given my obsession with flexibility and modularity, I set up the frontend so that it can
be swapped out with another one.  I need both a console-only "frontend" for Computie, and the minifb
frontend for the Sega Genesis, so I made separate crates for each.  Cargo has a "workspaces" feature
to make it easy to organize a single repository into multiple crates, each compiled separately.  The
Cargo.toml file in the root directory of the project needs the following lines:</p>
<div class="codehilite"><pre><span></span><code><span class="k">[workspace]</span>
<span class="n">members</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="s2">&quot;.&quot;</span><span class="p">,</span><span class="w"> </span><span class="s2">&quot;frontends/moa-console&quot;</span><span class="p">,</span><span class="w"> </span><span class="s2">&quot;frontends/moa-minifb&quot;</span><span class="p">]</span>
</code></pre></div>

<p>The first directory is the current directory, which has the common Moa code in <code>src/</code>, and
dependencies for that crate also go in the same Cargo.toml file in the root of the project.  Each of
the frontends have their own Cargo.toml files with their own dependencies and feature flags.  They
also contain files in <code>frontends/&lt;name&gt;/src/bin/&lt;machine&gt;.rs</code> which will be compiled into separate
binaries, one for each machine that can be run using that frontend, which makes it easier to run
different machines.  In this configuration, if using cargo to compile and run a given binary, both
the crate and binary name must be specified or else cargo will use the configured default.</p>
<p>The Genesis machine can be run using:</p>
<div class="codehilite"><pre><span></span><code>cargo run -p moa-minifb --bin moa-genesis
</code></pre></div>

<p>The <code>moa-genesis</code> binary looks something like this, with all the details hidden in <code>init_frontend</code>
and <code>start</code>:</p>
<div class="codehilite"><pre><span></span><code><span class="k">use</span><span class="w"> </span><span class="n">moa_minifb</span><span class="p">;</span>
<span class="k">use</span><span class="w"> </span><span class="n">moa</span><span class="p">::</span><span class="n">machines</span><span class="p">::</span><span class="n">genesis</span><span class="p">::</span><span class="n">build_genesis</span><span class="p">;</span>

<span class="k">fn</span><span class="w"> </span><span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">frontend</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">MiniFrontend</span><span class="p">::</span><span class="n">init_frontend</span><span class="p">();</span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">system</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">build_genesis</span><span class="p">(</span><span class="o">&amp;</span><span class="n">frontend</span><span class="p">).</span><span class="n">unwrap</span><span class="p">();</span>

<span class="w">    </span><span class="n">frontend</span><span class="p">.</span><span class="n">start</span><span class="p">(</span><span class="n">system</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>

<p>In order to provide a generic frontend-agnostic interface between the common Moa devices and a
specific frontend, there is a <code>Host</code> trait which is implemented by each frontend, and passed to the
machine building function to build the <code>System</code> object.  Through that trait, the machine definition
can register a callback for whichever devices need to output video data (which is machine-specific).
Separate callbacks can be registered through the same <code>Host</code> trait to get data from the keyboard or
controllers.</p>
<div class="codehilite"><pre><span></span><code><span class="k">pub</span><span class="w"> </span><span class="k">trait</span><span class="w"> </span><span class="n">Host</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">fn</span><span class="w"> </span><span class="nf">add_window</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">_updater</span><span class="p">:</span><span class="w"> </span><span class="nb">Box</span><span class="o">&lt;</span><span class="k">dyn</span><span class="w"> </span><span class="n">WindowUpdater</span><span class="o">&gt;</span><span class="p">)</span><span class="w"> </span><span class="p">-&gt;</span><span class="w"> </span><span class="nb">Result</span><span class="o">&lt;</span><span class="p">(),</span><span class="w"> </span><span class="n">Error</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="c1">// Default implementation if it&#39;s not defined in the &#39;impl Host for ...&#39;</span>
<span class="w">        </span><span class="nb">Err</span><span class="p">(</span><span class="n">Error</span><span class="p">::</span><span class="n">new</span><span class="p">(</span><span class="s">&quot;This frontend doesn&#39;t support windows&quot;</span><span class="p">))</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="k">fn</span><span class="w"> </span><span class="nf">register_controller</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">_device</span><span class="p">:</span><span class="w"> </span><span class="nc">ControllerDevice</span><span class="p">,</span><span class="w"> </span><span class="n">_input</span><span class="p">:</span><span class="w"> </span><span class="nb">Box</span><span class="o">&lt;</span><span class="k">dyn</span><span class="w"> </span><span class="n">ControllerUpdater</span><span class="o">&gt;</span><span class="p">)</span><span class="w"> </span><span class="p">-&gt;</span><span class="w"> </span><span class="nb">Result</span><span class="o">&lt;</span><span class="p">(),</span><span class="w"> </span><span class="n">Error</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="c1">// Default implementation if it&#39;s not defined in the &#39;impl Host for ...&#39;</span>
<span class="w">        </span><span class="nb">Err</span><span class="p">(</span><span class="n">Error</span><span class="p">::</span><span class="n">new</span><span class="p">(</span><span class="s">&quot;This frontend doesn&#39;t support game controllers&quot;</span><span class="p">))</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>

<span class="k">pub</span><span class="w"> </span><span class="k">trait</span><span class="w"> </span><span class="n">WindowUpdater</span><span class="p">:</span><span class="w"> </span><span class="nb">Send</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">fn</span><span class="w"> </span><span class="nf">get_size</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="bp">self</span><span class="p">)</span><span class="w"> </span><span class="p">-&gt;</span><span class="w"> </span><span class="p">(</span><span class="kt">u32</span><span class="p">,</span><span class="w"> </span><span class="kt">u32</span><span class="p">);</span>
<span class="w">    </span><span class="k">fn</span><span class="w"> </span><span class="nf">update_frame</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">width</span><span class="p">:</span><span class="w"> </span><span class="kt">u32</span><span class="p">,</span><span class="w"> </span><span class="n">height</span><span class="p">:</span><span class="w"> </span><span class="kt">u32</span><span class="p">,</span><span class="w"> </span><span class="n">bitmap</span><span class="p">:</span><span class="w"> </span><span class="kp">&amp;</span><span class="nc">mut</span><span class="w"> </span><span class="p">[</span><span class="kt">u32</span><span class="p">]);</span>
<span class="p">}</span>

<span class="k">pub</span><span class="w"> </span><span class="k">trait</span><span class="w"> </span><span class="n">ControllerUpdater</span><span class="p">:</span><span class="w"> </span><span class="nb">Send</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">fn</span><span class="w"> </span><span class="nf">update_controller</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">event</span><span class="p">:</span><span class="w"> </span><span class="nc">ControllerEvent</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>

<p>The <code>Host</code> trait is implemented by each frontend and passed to the function that builds the machine
configuration, before the simulation is started.  The machine configuration can choose to create a
window only when needed by that machine.  Not shown in the above snippet are the <code>Host</code> functions
to create PTYs (used only by Computie), and to register a keyboard updater (used by the TRS-80 and
Macintosh machines).</p>
<div class="codehilite"><pre><span></span><code><span class="k">pub</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">MiniFrontend</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="n">updater</span><span class="p">:</span><span class="w"> </span><span class="nb">Option</span><span class="o">&lt;</span><span class="nb">Box</span><span class="o">&lt;</span><span class="k">dyn</span><span class="w"> </span><span class="n">WindowUpdater</span><span class="o">&gt;&gt;</span><span class="p">,</span>
<span class="p">}</span>

<span class="k">impl</span><span class="w"> </span><span class="n">Host</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">MiniFrontend</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">fn</span><span class="w"> </span><span class="nf">add_window</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">updater</span><span class="p">:</span><span class="w"> </span><span class="nb">Box</span><span class="o">&lt;</span><span class="k">dyn</span><span class="w"> </span><span class="n">WindowUpdater</span><span class="o">&gt;</span><span class="p">)</span><span class="w"> </span><span class="p">-&gt;</span><span class="w"> </span><span class="nb">Result</span><span class="o">&lt;</span><span class="p">(),</span><span class="w"> </span><span class="n">Error</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="n">updater</span><span class="p">.</span><span class="n">is_some</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="k">return</span><span class="w"> </span><span class="nb">Err</span><span class="p">(</span><span class="n">Error</span><span class="p">::</span><span class="n">new</span><span class="p">(</span><span class="s">&quot;A window updater has already been registered with the frontend&quot;</span><span class="p">));</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">        </span><span class="bp">self</span><span class="p">.</span><span class="n">updater</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">Some</span><span class="p">(</span><span class="n">updater</span><span class="p">);</span>
<span class="w">        </span><span class="nb">Ok</span><span class="p">(())</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>

<span class="k">impl</span><span class="w"> </span><span class="n">MiniFrontend</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="k">fn</span><span class="w"> </span><span class="nf">init_frontend</span><span class="p">()</span><span class="w"> </span><span class="p">-&gt;</span><span class="w"> </span><span class="nc">MiniFrontend</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">MiniFrontend</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="n">updater</span><span class="p">:</span><span class="w"> </span><span class="nb">None</span><span class="p">,</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="k">fn</span><span class="w"> </span><span class="nf">start</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">system</span><span class="p">:</span><span class="w"> </span><span class="nc">System</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">buffer</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="fm">vec!</span><span class="p">[</span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">WIDTH</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">HEIGHT</span><span class="p">]</span>
<span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">options</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">minifb</span><span class="p">::</span><span class="n">WindowOptions</span><span class="p">::</span><span class="n">default</span><span class="p">();</span>
<span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">window</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">minifb</span><span class="p">::</span><span class="n">Window</span><span class="p">::</span><span class="n">new</span><span class="p">(</span><span class="s">&quot;Test&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">WIDTH</span><span class="p">,</span><span class="w"> </span><span class="n">HEIGHT</span><span class="p">,</span><span class="w"> </span><span class="n">options</span><span class="p">).</span><span class="n">unwrap</span><span class="p">();</span>

<span class="w">        </span><span class="c1">// Limit to max ~60 fps update rate</span>
<span class="w">        </span><span class="n">window</span><span class="p">.</span><span class="n">limit_update_rate</span><span class="p">(</span><span class="nb">Some</span><span class="p">(</span><span class="n">Duration</span><span class="p">::</span><span class="n">from_micros</span><span class="p">(</span><span class="mi">16600</span><span class="p">)));</span>

<span class="w">        </span><span class="k">while</span><span class="w"> </span><span class="n">window</span><span class="p">.</span><span class="n">is_open</span><span class="p">()</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="o">!</span><span class="n">window</span><span class="p">.</span><span class="n">is_key_down</span><span class="p">(</span><span class="n">Key</span><span class="p">::</span><span class="n">Escape</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="c1">// Run the simulation for 16.6ms, the same as the frame limiter</span>
<span class="w">            </span><span class="n">system</span><span class="p">.</span><span class="n">run_for</span><span class="p">(</span><span class="mi">16_600_000</span><span class="p">).</span><span class="n">unwrap</span><span class="p">();</span>

<span class="w">            </span><span class="k">if</span><span class="w"> </span><span class="kd">let</span><span class="w"> </span><span class="nb">Some</span><span class="p">(</span><span class="n">updater</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="n">updater</span><span class="w"> </span><span class="p">{</span>
<span class="w">                </span><span class="n">updater</span><span class="p">.</span><span class="n">update_frame</span><span class="p">(</span><span class="n">WIDTH</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="kt">u32</span><span class="p">,</span><span class="w"> </span><span class="n">HEIGHT</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="kt">u32</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="n">buffer</span><span class="p">);</span>
<span class="w">                </span><span class="n">window</span><span class="p">.</span><span class="n">update_with_buffer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">buffer</span><span class="p">,</span><span class="w"> </span><span class="n">WIDTH</span><span class="p">,</span><span class="w"> </span><span class="n">HEIGHT</span><span class="p">).</span><span class="n">unwrap</span><span class="p">();</span>
<span class="w">            </span><span class="p">}</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</code></pre></div>

<p>There's not much to it.  Only one window can be created at the moment, and input is not yet
supported.  The threaded option is also not shown here.  Before long, the code grew more
complicated, and now includes parsing of command line arguments with the <code>clap</code> crate.  To see the
latest version, check out the <a href="https://github.com/transistorfet/moa/blob/c3951999771bbb56f45e1a8c5cd0b61758aed778/frontends/moa-minifb/src/bin/moa-genesis.rs">Genesis machine-specific
binary</a>
and the <a href="https://github.com/transistorfet/moa/blob/c3951999771bbb56f45e1a8c5cd0b61758aed778/frontends/moa-minifb/src/lib.rs">MiniFB host impl and main
loop</a></p>
<h2 id="updating-windows">Updating Windows</h2>
<p>I now needed to implement the <code>WindowUpdater</code> trait and to do this, I made a <code>Frame</code> object which
holds a single frame in a buffer.  When the update function is called, the frame buffer will be
copied to the minifb buffer.  Pixel data can be fed to the <code>.blit</code> function using an Iterator,
rather than using yet another intermediate buffer for individual images drawn to the frame.  The
<code>Arc&lt;Mutex&lt;Frame&gt;&gt;</code> used in the updater is necessary for the threaded version, so that the frame can
be held both by the simulation thread and by the UI thread at the same time.</p>
<div class="codehilite"><pre><span></span><code><span class="c1">// If a pixel has this value, it wont be copied to the buffer</span>
<span class="k">const</span><span class="w"> </span><span class="n">MASK_COLOUR</span><span class="p">:</span><span class="w"> </span><span class="kt">u32</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">0xFFFFFFFF</span><span class="p">;</span>

<span class="k">pub</span><span class="w"> </span><span class="k">trait</span><span class="w"> </span><span class="n">BlitableSurface</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">fn</span><span class="w"> </span><span class="nf">blit</span><span class="o">&lt;</span><span class="n">B</span><span class="p">:</span><span class="w"> </span><span class="nb">Iterator</span><span class="o">&lt;</span><span class="n">Item</span><span class="o">=</span><span class="kt">u32</span><span class="o">&gt;&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">pos_x</span><span class="p">:</span><span class="w"> </span><span class="kt">u32</span><span class="p">,</span><span class="w"> </span><span class="n">pos_y</span><span class="p">:</span><span class="w"> </span><span class="kt">u32</span><span class="p">,</span><span class="w"> </span><span class="n">bitmap</span><span class="p">:</span><span class="w"> </span><span class="nc">B</span><span class="p">,</span><span class="w"> </span><span class="n">width</span><span class="p">:</span><span class="w"> </span><span class="kt">u32</span><span class="p">,</span><span class="w"> </span><span class="n">height</span><span class="p">:</span><span class="w"> </span><span class="kt">u32</span><span class="p">);</span>
<span class="w">    </span><span class="k">fn</span><span class="w"> </span><span class="nf">clear</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">value</span><span class="p">:</span><span class="w"> </span><span class="kt">u32</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#[derive(Clone)]</span>
<span class="k">pub</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">Frame</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="n">width</span><span class="p">:</span><span class="w"> </span><span class="kt">u32</span><span class="p">,</span>
<span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="n">height</span><span class="p">:</span><span class="w"> </span><span class="kt">u32</span><span class="p">,</span>
<span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="n">bitmap</span><span class="p">:</span><span class="w"> </span><span class="nb">Vec</span><span class="o">&lt;</span><span class="kt">u32</span><span class="o">&gt;</span><span class="p">,</span>
<span class="p">}</span>

<span class="k">impl</span><span class="w"> </span><span class="n">Frame</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="k">fn</span><span class="w"> </span><span class="nf">new</span><span class="p">(</span><span class="n">width</span><span class="p">:</span><span class="w"> </span><span class="kt">u32</span><span class="p">,</span><span class="w"> </span><span class="n">height</span><span class="p">:</span><span class="w"> </span><span class="kt">u32</span><span class="p">)</span><span class="w"> </span><span class="p">-&gt;</span><span class="w"> </span><span class="nc">Self</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="bp">Self</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">width</span><span class="p">,</span><span class="w"> </span><span class="n">height</span><span class="p">,</span><span class="w"> </span><span class="n">bitmap</span><span class="p">:</span><span class="w"> </span><span class="nc">vec</span><span class="o">!</span><span class="p">[</span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="p">(</span><span class="n">width</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">height</span><span class="p">)</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="kt">usize</span><span class="p">]</span><span class="w"> </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>

<span class="k">impl</span><span class="w"> </span><span class="n">BlitableSurface</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">Frame</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">fn</span><span class="w"> </span><span class="nf">blit</span><span class="o">&lt;</span><span class="n">B</span><span class="p">:</span><span class="w"> </span><span class="nb">Iterator</span><span class="o">&lt;</span><span class="n">Item</span><span class="o">=</span><span class="kt">u32</span><span class="o">&gt;&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">pos_x</span><span class="p">:</span><span class="w"> </span><span class="kt">u32</span><span class="p">,</span><span class="w"> </span><span class="n">pos_y</span><span class="p">:</span><span class="w"> </span><span class="kt">u32</span><span class="p">,</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">bitmap</span><span class="p">:</span><span class="w"> </span><span class="nc">B</span><span class="p">,</span><span class="w"> </span><span class="n">width</span><span class="p">:</span><span class="w"> </span><span class="kt">u32</span><span class="p">,</span><span class="w"> </span><span class="n">height</span><span class="p">:</span><span class="w"> </span><span class="kt">u32</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">for</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="n">pos_y</span><span class="o">..</span><span class="p">(</span><span class="n">pos_y</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">height</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="k">for</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="n">pos_x</span><span class="o">..</span><span class="p">(</span><span class="n">pos_x</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">width</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">                </span><span class="k">match</span><span class="w"> </span><span class="n">bitmap</span><span class="p">.</span><span class="n">next</span><span class="p">().</span><span class="n">unwrap</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">                    </span><span class="n">MASK_COLOUR</span><span class="w"> </span><span class="o">=&gt;</span>
<span class="w">                        </span><span class="p">{</span><span class="w"> </span><span class="p">},</span>
<span class="w">                    </span><span class="n">value</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="n">width</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="n">height</span><span class="w"> </span><span class="o">=&gt;</span>
<span class="w">                        </span><span class="p">{</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="n">bitmap</span><span class="p">[(</span><span class="n">x</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="p">(</span><span class="n">y</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="n">width</span><span class="p">))</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="kt">usize</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">value</span><span class="p">;</span><span class="w"> </span><span class="p">},</span>
<span class="w">                    </span><span class="n">_</span><span class="w"> </span><span class="o">=&gt;</span>
<span class="w">                        </span><span class="p">{</span><span class="w"> </span><span class="p">},</span>
<span class="w">                </span><span class="p">}</span>
<span class="w">            </span><span class="p">}</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="k">fn</span><span class="w"> </span><span class="nf">clear</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">value</span><span class="p">:</span><span class="w"> </span><span class="kt">u32</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">value</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="n">value</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">MASK_COLOUR</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">value</span><span class="w"> </span><span class="p">};</span>
<span class="w">        </span><span class="k">for</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="mi">0</span><span class="o">..</span><span class="p">((</span><span class="bp">self</span><span class="p">.</span><span class="n">width</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="kt">usize</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="p">(</span><span class="bp">self</span><span class="p">.</span><span class="n">height</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="kt">usize</span><span class="p">))</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="bp">self</span><span class="p">.</span><span class="n">bitmap</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">value</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>

<span class="k">pub</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">FrameUpdateWrapper</span><span class="p">(</span><span class="n">Arc</span><span class="o">&lt;</span><span class="n">Mutex</span><span class="o">&lt;</span><span class="n">Frame</span><span class="o">&gt;&gt;</span><span class="p">);</span>

<span class="k">impl</span><span class="w"> </span><span class="n">WindowUpdater</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">FrameUpdateWrapper</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">fn</span><span class="w"> </span><span class="nf">get_size</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="bp">self</span><span class="p">)</span><span class="w"> </span><span class="p">-&gt;</span><span class="w"> </span><span class="p">(</span><span class="kt">u32</span><span class="p">,</span><span class="w"> </span><span class="kt">u32</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">frame</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="mf">0.</span><span class="n">lock</span><span class="p">().</span><span class="n">unwrap</span><span class="p">();</span>
<span class="w">        </span><span class="p">(</span><span class="n">frame</span><span class="p">.</span><span class="n">width</span><span class="p">,</span><span class="w"> </span><span class="n">frame</span><span class="p">.</span><span class="n">height</span><span class="p">)</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="k">fn</span><span class="w"> </span><span class="nf">update_frame</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">width</span><span class="p">:</span><span class="w"> </span><span class="kt">u32</span><span class="p">,</span><span class="w"> </span><span class="n">_height</span><span class="p">:</span><span class="w"> </span><span class="kt">u32</span><span class="p">,</span><span class="w"> </span><span class="n">bitmap</span><span class="p">:</span><span class="w"> </span><span class="kp">&amp;</span><span class="nc">mut</span><span class="w"> </span><span class="p">[</span><span class="kt">u32</span><span class="p">])</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">frame</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="mf">0.</span><span class="n">lock</span><span class="p">().</span><span class="n">unwrap</span><span class="p">();</span>
<span class="w">        </span><span class="k">for</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="mi">0</span><span class="o">..</span><span class="n">frame</span><span class="p">.</span><span class="n">height</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="k">for</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="mi">0</span><span class="o">..</span><span class="n">frame</span><span class="p">.</span><span class="n">width</span><span class="w"> </span><span class="p">{</span>
<span class="w">                </span><span class="n">bitmap</span><span class="p">[(</span><span class="n">x</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="p">(</span><span class="n">y</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">width</span><span class="p">))</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="kt">usize</span><span class="p">]</span><span class="w"> </span><span class="o">=</span>
<span class="w">                    </span><span class="n">frame</span><span class="p">.</span><span class="n">bitmap</span><span class="p">[(</span><span class="n">x</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="p">(</span><span class="n">y</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">frame</span><span class="p">.</span><span class="n">width</span><span class="p">))</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="kt">usize</span><span class="p">];</span>
<span class="w">            </span><span class="p">}</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</code></pre></div>

<p>I know I'm copying the buffer twice when updating the frame, but it's a compromise in the name of
flexibility.  A buffer held only by the frontend is passed into <code>WindowUpdate::update_frame()</code>, into
which the frame data is copied, and then that frontend buffer is passed to minifb's
<code>.update_with_buffer()</code> function.  The trouble is that minifb uses its <code>.update_with_buffer()</code>
function to also limit the frame rate.  The frame limiter is set to 60 updates a second, and the
delay that's necessary to achieve that limit happens before the update function returns.  The delay
is typically between 10 to 12 ms in order to achieve a total 16.6ms delay between frames.</p>
<p>If the shared frame buffer is passed to the minifb update function, the lock on the frame will be
held until the delay expires and the function returns.  If the simulation code is run between
frames, then holding the lock isn't so much a problem because it's only after the update function
returns that the frame will be accessed, but if the simulation is run in a separate thread, then the
lock contention makes the frame rate excruciatingly slow.  Since I wanted the option to run the
simulation in a separate thread, and since the extra buffer copy is negligible on a typical desktop,
I've kept it, but if I ever try to run in on slower hardware, I might see about redesigning this.</p>
<p>There is also the issue of partial frames.  Currently the VDP simulation code draws an entire frame
at once instead of more accurately drawing it line by line spread out over many calls to its step
function.  I suspect that this causes the issue with the Sonic 2 title screen where Tails appears to
be an incorrect colour.  The ROM might be trying to change the colour palette while the image is
being updated in order to pack more colours onto the screen at once.</p>
<p>The advantage of updating all at once, however, is that the frame will always be completely drawn
when the frame buffer lock is obtained.  I had originally written some code have two frames, and to
swap them after each draw cycle is complete, so that there's always a complete frame available when
the screen is updated.  If the simulation is running slow, then the same completed frame will be
sent more than once.  If it's too fast, then some frames wont be sent to the screen at all before
being redrawn.  This turned out to not be necessary because of the all-at-once update, but since I
will likely need to change to line-by-line updating in the future, the <code>FrameSwapper</code> code has been
left in place in the actual Moa code.</p>
<h2 id="the-vdp-device">The VDP Device</h2>
<p>I can now add the frame buffer to the VDP device, including the call to <code>.add_window()</code> to register
it with the frontend, and some logic to handle the horizontal and vertical interrupts.</p>
<div class="codehilite"><pre><span></span><code><span class="k">pub</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">Ym7101State</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="n">regs</span><span class="p">:</span><span class="w"> </span><span class="p">[</span><span class="mi">22</span><span class="p">;</span><span class="w"> </span><span class="kt">u8</span><span class="p">],</span><span class="w">                 </span><span class="c1">// The internal registers of the VDP</span>

<span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="n">last_clock</span><span class="p">:</span><span class="w"> </span><span class="nc">Clock</span><span class="p">,</span>
<span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="n">h_clock</span><span class="p">:</span><span class="w"> </span><span class="kt">u32</span><span class="p">,</span><span class="w">                   </span><span class="c1">// Used to generate the horizontal interrupt</span>
<span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="n">v_clock</span><span class="p">:</span><span class="w"> </span><span class="kt">u32</span><span class="p">,</span><span class="w">                   </span><span class="c1">// Used to generate the vertical interrupt</span>
<span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="n">h_scanlines</span><span class="p">:</span><span class="w"> </span><span class="kt">u32</span><span class="p">,</span>

<span class="w">    </span><span class="o">..</span><span class="p">.</span><span class="w">                                 </span><span class="c1">// Additional fields used by memory/DMA code</span>
<span class="p">}</span>

<span class="k">pub</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">Ym7101</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="n">frame</span><span class="p">:</span><span class="w"> </span><span class="nc">Arc</span><span class="o">&lt;</span><span class="n">Mutex</span><span class="o">&lt;</span><span class="n">Frame</span><span class="o">&gt;&gt;</span><span class="p">,</span><span class="w">       </span><span class="c1">// The output video frame, shared with the frontend</span>
<span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="n">state</span><span class="p">:</span><span class="w"> </span><span class="nc">Ym7101State</span><span class="p">,</span>
<span class="p">}</span>

<span class="k">impl</span><span class="w"> </span><span class="n">Ym7101</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="k">fn</span><span class="w"> </span><span class="nf">new</span><span class="o">&lt;</span><span class="n">H</span><span class="p">:</span><span class="w"> </span><span class="nc">Host</span><span class="o">&gt;</span><span class="p">(</span><span class="n">host</span><span class="p">:</span><span class="w"> </span><span class="kp">&amp;</span><span class="nc">H</span><span class="p">)</span><span class="w"> </span><span class="p">-&gt;</span><span class="w"> </span><span class="nc">Ym7101</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">frame</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Frame</span><span class="p">::</span><span class="n">new</span><span class="p">(</span><span class="mi">320</span><span class="p">,</span><span class="w"> </span><span class="mi">224</span><span class="p">);</span>

<span class="w">        </span><span class="n">host</span><span class="p">.</span><span class="n">add_window</span><span class="p">(</span><span class="nb">Box</span><span class="p">::</span><span class="n">new</span><span class="p">(</span><span class="n">frame</span><span class="p">.</span><span class="n">clone</span><span class="p">()));</span>

<span class="w">        </span><span class="n">Ym7101</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="n">frame</span><span class="p">,</span>
<span class="w">            </span><span class="n">state</span><span class="p">:</span><span class="w"> </span><span class="nc">Ym7101State</span><span class="p">::</span><span class="n">new</span><span class="p">(),</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>

<span class="k">impl</span><span class="w"> </span><span class="n">Steppable</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">Ym7101</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">fn</span><span class="w"> </span><span class="nf">step</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">system</span><span class="p">:</span><span class="w"> </span><span class="kp">&amp;</span><span class="nc">System</span><span class="p">)</span><span class="w"> </span><span class="p">-&gt;</span><span class="w"> </span><span class="nb">Result</span><span class="o">&lt;</span><span class="n">ClockElapsed</span><span class="p">,</span><span class="w"> </span><span class="n">Error</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="c1">// Calculate the actual time since the last step occured</span>
<span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">diff</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">system</span><span class="p">.</span><span class="n">clock</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="n">state</span><span class="p">.</span><span class="n">last_clock</span><span class="p">)</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="kt">u32</span><span class="p">;</span>
<span class="w">        </span><span class="bp">self</span><span class="p">.</span><span class="n">state</span><span class="p">.</span><span class="n">last_clock</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">system</span><span class="p">.</span><span class="n">clock</span><span class="p">;</span>

<span class="w">        </span><span class="c1">// Reset the interrupts</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="n">state</span><span class="p">.</span><span class="n">reset_int</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="n">system</span><span class="p">.</span><span class="n">get_interrupt_controller</span><span class="p">().</span><span class="n">set</span><span class="p">(</span><span class="kc">false</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="p">,</span><span class="w"> </span><span class="mi">28</span><span class="p">)</span><span class="o">?</span><span class="p">;</span>
<span class="w">            </span><span class="n">system</span><span class="p">.</span><span class="n">get_interrupt_controller</span><span class="p">().</span><span class="n">set</span><span class="p">(</span><span class="kc">false</span><span class="p">,</span><span class="w"> </span><span class="mi">6</span><span class="p">,</span><span class="w"> </span><span class="mi">30</span><span class="p">)</span><span class="o">?</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span>

<span class="w">        </span><span class="bp">self</span><span class="p">.</span><span class="n">state</span><span class="p">.</span><span class="n">h_clock</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">diff</span><span class="p">;</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="n">state</span><span class="p">.</span><span class="n">h_clock</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">63_500</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="bp">self</span><span class="p">.</span><span class="n">state</span><span class="p">.</span><span class="n">h_clock</span><span class="w"> </span><span class="o">-=</span><span class="w"> </span><span class="mi">63_500</span><span class="p">;</span>

<span class="w">            </span><span class="c1">// Trigger the horizontal interrupt</span>
<span class="w">            </span><span class="c1">//   The H Interrupt register has the number of lines that should be</span>
<span class="w">            </span><span class="c1">//   drawn before the interrupt occurs</span>
<span class="w">            </span><span class="bp">self</span><span class="p">.</span><span class="n">state</span><span class="p">.</span><span class="n">h_scanlines</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="n">state</span><span class="p">.</span><span class="n">h_scanlines</span><span class="p">.</span><span class="n">wrapping_add</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
<span class="w">            </span><span class="k">if</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="n">state</span><span class="p">.</span><span class="n">hsync_int_enabled</span><span class="p">()</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="n">state</span><span class="p">.</span><span class="n">h_scanlines</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="n">state</span><span class="p">.</span><span class="n">regs</span><span class="p">[</span><span class="n">REG_H_INTERRUPT</span><span class="p">]</span><span class="w"> </span><span class="p">{</span>
<span class="w">                </span><span class="bp">self</span><span class="p">.</span><span class="n">state</span><span class="p">.</span><span class="n">h_scanlines</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">                </span><span class="n">system</span><span class="p">.</span><span class="n">get_interrupt_controller</span><span class="p">().</span><span class="n">set</span><span class="p">(</span><span class="kc">true</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="p">,</span><span class="w"> </span><span class="mi">28</span><span class="p">)</span><span class="o">?</span><span class="p">;</span>
<span class="w">                </span><span class="bp">self</span><span class="p">.</span><span class="n">state</span><span class="p">.</span><span class="n">reset_int</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kc">true</span><span class="p">;</span>
<span class="w">            </span><span class="p">}</span>
<span class="w">        </span><span class="p">}</span>

<span class="w">        </span><span class="bp">self</span><span class="p">.</span><span class="n">state</span><span class="p">.</span><span class="n">v_clock</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">diff</span><span class="p">;</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="n">state</span><span class="p">.</span><span class="n">v_clock</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">16_630_000</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="bp">self</span><span class="p">.</span><span class="n">state</span><span class="p">.</span><span class="n">v_clock</span><span class="w"> </span><span class="o">-=</span><span class="w"> </span><span class="mi">16_630_000</span><span class="p">;</span>

<span class="w">            </span><span class="c1">// Trigger the vertical interrupt</span>
<span class="w">            </span><span class="k">if</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="n">state</span><span class="p">.</span><span class="n">vsync_int_enabled</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">                </span><span class="n">system</span><span class="p">.</span><span class="n">get_interrupt_controller</span><span class="p">().</span><span class="n">set</span><span class="p">(</span><span class="kc">true</span><span class="p">,</span><span class="w"> </span><span class="mi">6</span><span class="p">,</span><span class="w"> </span><span class="mi">30</span><span class="p">)</span><span class="o">?</span><span class="p">;</span>
<span class="w">                </span><span class="bp">self</span><span class="p">.</span><span class="n">state</span><span class="p">.</span><span class="n">reset_int</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kc">true</span><span class="p">;</span>
<span class="w">            </span><span class="p">}</span>

<span class="w">            </span><span class="c1">// Lock the frame and update it</span>
<span class="w">            </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">frame</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="n">frame</span><span class="p">.</span><span class="n">lock</span><span class="p">().</span><span class="n">unwrap</span><span class="p">();</span>
<span class="w">            </span><span class="bp">self</span><span class="p">.</span><span class="n">state</span><span class="p">.</span><span class="n">draw_frame</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="n">frame</span><span class="p">);</span>
<span class="w">        </span><span class="p">}</span>

<span class="w">        </span><span class="c1">// Run the DMA transfer if configured</span>
<span class="w">        </span><span class="bp">self</span><span class="p">.</span><span class="n">state</span><span class="p">.</span><span class="n">step_dma</span><span class="p">(</span><span class="n">system</span><span class="p">)</span><span class="o">?</span><span class="p">;</span>

<span class="w">        </span><span class="nb">Ok</span><span class="p">((</span><span class="mi">1_000_000_000</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="mi">13_423_294</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">4</span><span class="p">)</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</code></pre></div>

<p>The <code>.step()</code> function will increment the <code>v_clock</code> until it has counted the number of nanoseconds
between refreshes on an NTSC television, which is 16.63 milliseconds.  At that point, it will
trigger the vertical interrupt and update the frame all at once.  There is also a horizontal
interrupt which can be configured to trigger only after a certain number of lines have been drawn.</p>
<p>I've shown here the original way I implemented interrupts, which was only intended to be temporary.
It definitely caused problems and was fixed not long after, but I'll go into more detail in Part III
where I talk about the process of debugging.</p>
<h2 id="colours-and-patterns">Colours And Patterns</h2>
<p>Before anything can be drawn, there needs to be some colours, and all the colours drawn by the VDP
are stored in the CRAM.  The CRAM can hold up to 4 different 16-colour palettes, with each palette
colour specified as a 9-bit RGB colour, which is actually organized as a 12-bit colour in a 16-bit
memory location. (Yikes)  The extra bits are not actually implemented in the hardware VDP to save
space on the chip, but for the purposes of emulating, I'll just store each colour in a 16-bit word.
This means CRAM will be 128 bytes in size.  The colours are actually stored in BGR order in the
word, so a middle red colour would be 0x008 and a middle blue colour would be 0x800.  To make the
brightest white, the colour value would be 0xEEE (since the lower bit of each RGB component is
always 0).</p>
<p>Technically this allows up to 512 different colours to be displayed, but only 64 of them can be on
the screen at once because of the limited palette size.  A further limit is that the <code>0</code> colour of
each palette is a special mask colour which won't be drawn, so that any pixel below it will show
through.  This is especially useful for sprites, so that they can be drawn on top of the other
graphics without squared edges.  There are also special highlight and shadow modes which shift the
colour output either high or low so that the 9-bit colour value is spread across only half of the
colour range, which increases the total possible colours that can be displayed.  That feature has
some complex conditions to determine when to use the shadow or highlight mode, so I just left it
unimplemented for the time being.</p>
<p>All graphics generated by the VDP are made up of 8x8 pixel images called cells.  A cell is generated
using a pattern which contains the pixel data, in combination with a palette number.  Each pixel in
the pattern is a 4-bit number, which selects one of 16 colours from the current colour palette.
That means each pattern is 32 bytes long, and each byte in the pattern will contain two pixels of
data with the upper nibble being the first pixel, and the lower nibble being the second.  The first
pixel in the first byte corresponds to the upper left hand corner of the pattern, and the pixels are
organized from left to right, top to bottom.</p>
<p>All the patterns must be in VRAM to be drawn, and they start from address 0 in VRAM, with the first
32 bytes being pattern 0, the next 32 bytes being pattern 1, and so on.  When a pattern is
referenced, an 11-bit number is used, which is then multiplied by 32 (or shifted to the left by 5
bits) to get the address in VRAM where the patterns starts.  So a pattern can be anywhere in the
64KB of VRAM, so long as it's aligned to a 32 byte boundary.  The pattern reference also includes
the palette number to use for drawing the pattern, and whether the pattern should be reversed in the
horizontal and/or vertical direction.  This allows the same pattern to be used more often, saving
space in VRAM.</p>
<p>Since generating the pattern data takes some translation, I opted to use an iterator to return the
data.  Each iteration will return one of 64 pixels as a 32-bit number which can then be written
directly to the frame buffer.</p>
<div class="codehilite"><pre><span></span><code><span class="k">pub</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">PatternIterator</span><span class="o">&lt;&#39;</span><span class="na">a</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">state</span><span class="p">:</span><span class="w"> </span><span class="kp">&amp;</span><span class="o">&#39;</span><span class="na">a</span><span class="w"> </span><span class="nc">Ym7101State</span><span class="p">,</span><span class="w">     </span><span class="c1">// A stored reference which is needed to access the colour values</span>
<span class="w">    </span><span class="n">palette</span><span class="p">:</span><span class="w"> </span><span class="kt">u8</span><span class="p">,</span><span class="w">                </span><span class="c1">// The palette number (0-3)</span>
<span class="w">    </span><span class="n">base</span><span class="p">:</span><span class="w"> </span><span class="kt">usize</span><span class="p">,</span><span class="w">                </span><span class="c1">// The base address in VRAM where the pattern starts</span>
<span class="w">    </span><span class="n">h_rev</span><span class="p">:</span><span class="w"> </span><span class="kt">bool</span><span class="p">,</span><span class="w">                </span><span class="c1">// Whether to reverse it horizontally</span>
<span class="w">    </span><span class="n">v_rev</span><span class="p">:</span><span class="w"> </span><span class="kt">bool</span><span class="p">,</span><span class="w">                </span><span class="c1">// Whether to reverse it vertically</span>
<span class="w">    </span><span class="n">line</span><span class="p">:</span><span class="w"> </span><span class="kt">i8</span><span class="p">,</span><span class="w">                   </span><span class="c1">// Current line (needed by reversing code)</span>
<span class="w">    </span><span class="n">col</span><span class="p">:</span><span class="w"> </span><span class="kt">i8</span><span class="p">,</span><span class="w">                    </span><span class="c1">// Current column (needed by reversing code)</span>
<span class="w">    </span><span class="n">second</span><span class="p">:</span><span class="w"> </span><span class="kt">bool</span><span class="p">,</span><span class="w">               </span><span class="c1">// Whether this is the second pixel (lower nibble) in the byte</span>
<span class="p">}</span>

<span class="k">impl</span><span class="o">&lt;&#39;</span><span class="na">a</span><span class="o">&gt;</span><span class="w"> </span><span class="n">PatternIterator</span><span class="o">&lt;&#39;</span><span class="na">a</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="k">fn</span><span class="w"> </span><span class="nf">new</span><span class="p">(</span><span class="n">state</span><span class="p">:</span><span class="w"> </span><span class="kp">&amp;</span><span class="o">&#39;</span><span class="na">a</span><span class="w"> </span><span class="nc">Ym7101State</span><span class="p">,</span><span class="w"> </span><span class="n">start</span><span class="p">:</span><span class="w"> </span><span class="kt">u32</span><span class="p">,</span><span class="w"> </span><span class="n">palette</span><span class="p">:</span><span class="w"> </span><span class="kt">u8</span><span class="p">,</span><span class="w"> </span><span class="n">h_rev</span><span class="p">:</span><span class="w"> </span><span class="kt">bool</span><span class="p">,</span><span class="w"> </span><span class="n">v_rev</span><span class="p">:</span><span class="w"> </span><span class="kt">bool</span><span class="p">)</span><span class="w"> </span><span class="p">-&gt;</span><span class="w"> </span><span class="nc">Self</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="bp">Self</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="n">state</span><span class="p">,</span>
<span class="w">            </span><span class="n">palette</span><span class="p">,</span>
<span class="w">            </span><span class="n">base</span><span class="p">:</span><span class="w"> </span><span class="nc">start</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="kt">usize</span><span class="p">,</span>
<span class="w">            </span><span class="n">h_rev</span><span class="p">,</span>
<span class="w">            </span><span class="n">v_rev</span><span class="p">,</span>
<span class="w">            </span><span class="n">line</span><span class="p">:</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span>
<span class="w">            </span><span class="n">col</span><span class="p">:</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span>
<span class="w">            </span><span class="n">second</span><span class="p">:</span><span class="w"> </span><span class="nc">false</span><span class="p">,</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>

<span class="k">impl</span><span class="o">&lt;&#39;</span><span class="na">a</span><span class="o">&gt;</span><span class="w"> </span><span class="nb">Iterator</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">PatternIterator</span><span class="o">&lt;&#39;</span><span class="na">a</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">type</span><span class="w"> </span><span class="nc">Item</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kt">u32</span><span class="p">;</span>

<span class="w">    </span><span class="k">fn</span><span class="w"> </span><span class="nf">next</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="bp">self</span><span class="p">)</span><span class="w"> </span><span class="p">-&gt;</span><span class="w"> </span><span class="nb">Option</span><span class="o">&lt;</span><span class="bp">Self</span><span class="p">::</span><span class="n">Item</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">line</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="k">if</span><span class="w"> </span><span class="o">!</span><span class="bp">self</span><span class="p">.</span><span class="n">v_rev</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="n">line</span><span class="w"> </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="mi">7</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="n">line</span><span class="w"> </span><span class="p">})</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="kt">usize</span><span class="p">;</span>
<span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">column</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="k">if</span><span class="w"> </span><span class="o">!</span><span class="bp">self</span><span class="p">.</span><span class="n">h_rev</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="n">col</span><span class="w"> </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="n">col</span><span class="w"> </span><span class="p">})</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="kt">usize</span><span class="p">;</span>
<span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">offset</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="n">base</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">line</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">4</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">column</span><span class="p">;</span>

<span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">value</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="bp">self</span><span class="p">.</span><span class="n">h_rev</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="o">!</span><span class="bp">self</span><span class="p">.</span><span class="n">second</span><span class="p">)</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="p">(</span><span class="bp">self</span><span class="p">.</span><span class="n">h_rev</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="n">second</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="bp">self</span><span class="p">.</span><span class="n">state</span><span class="p">.</span><span class="n">get_palette_colour</span><span class="p">(</span><span class="bp">self</span><span class="p">.</span><span class="n">palette</span><span class="p">,</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="n">state</span><span class="p">.</span><span class="n">vram</span><span class="p">[</span><span class="n">offset</span><span class="p">]</span><span class="w"> </span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="mi">4</span><span class="p">)</span>
<span class="w">        </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="bp">self</span><span class="p">.</span><span class="n">state</span><span class="p">.</span><span class="n">get_palette_colour</span><span class="p">(</span><span class="bp">self</span><span class="p">.</span><span class="n">palette</span><span class="p">,</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="n">state</span><span class="p">.</span><span class="n">vram</span><span class="p">[</span><span class="n">offset</span><span class="p">]</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="mh">0x0f</span><span class="p">)</span>
<span class="w">        </span><span class="p">};</span>

<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="o">!</span><span class="bp">self</span><span class="p">.</span><span class="n">second</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="bp">self</span><span class="p">.</span><span class="n">second</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kc">true</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="bp">self</span><span class="p">.</span><span class="n">second</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kc">false</span><span class="p">;</span>
<span class="w">            </span><span class="bp">self</span><span class="p">.</span><span class="n">col</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="w">            </span><span class="k">if</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="n">col</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="mi">4</span><span class="w"> </span><span class="p">{</span>
<span class="w">                </span><span class="bp">self</span><span class="p">.</span><span class="n">col</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">                </span><span class="bp">self</span><span class="p">.</span><span class="n">line</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="w">            </span><span class="p">}</span>
<span class="w">        </span><span class="p">}</span>

<span class="w">        </span><span class="nb">Some</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</code></pre></div>

<p>It's a bit messy, and I'm sure I could optimize it, but it works for now.  At this point I'm still
focused on getting something working more than cleaning up and optimizing the code.  (Note: I ended
up throwing this code away, which goes to show it's not always worth getting hung up on the quality
of code when in early development and things are changing rapidly.  I'll talk more about the change
in Part III).</p>
<h2 id="scrolls-and-sprites">Scrolls And Sprites</h2>
<p>Now that there's a way to draw cells to the screen, how is the VDP told which ones to draw and
where?  There are two ways.  They can either be specified in one of the two scroll tables, or they
can be specified in a sprite.</p>
<p>There are two moveable planes called Scroll A and Scroll B, the tables for which are stored in VRAM
and the starting address of each table is stored in their own VDP registers.  Each table is an array
of 16-bit words where each word is called a pattern name and contains the pattern number, the colour
palette to render it with, two bits to reverse the pattern in the horizontal and/or vertical
direction, and a priority bit used to determine the draw order of the different planes.  The exact
format in memory is better shown at
<a href="https://wiki.megadrive.org/index.php?title=VDP_Scrolls">megadrive.org</a> and
<a href="https://segaretro.org/Sega_Mega_Drive/Planes">segaretro.org</a></p>
<p>Both scrolls must be the same size, but the size can be any combination of 32, 64, or 128 cells in
either direction.  This means they are usually bigger than the size of the screen itself, which for
the NTSC version is usually 40 x 28 cells (320 x 224 pixels).  Which portion of the scroll plane to
draw on the screen can be controlled using the scrolling features of the VDP, which at its simplest
is just two numbers per plane to specify the vertical and horizontal offset of the scroll relative
to the upper left corner of the screen, but at it's most complex can have a different offset for
each line of pixels which controls the horizontal position of each line.  I left the scrolling
functionality unimplemented until the scroll planes were working, so I'll go into more detail about
it later.  For the logo and title screens, there usually isn't a scroll offset, so displaying the
upper left corner of the scroll at the upper left corner of the screen should still display
something.</p>
<p>There is also a special fixed plane called the window, but not many games seem to use it and my
early attempts at implementing it caused weird graphics, so I left it for later.</p>
<p>The other way to draw to the screen is using sprites.  Like the scrolls, a table of sprite data is
stored in VRAM and a special register contains the address of the start of that table.  Unlike the
scrolls, each entry in the sprite table is four 16-bit words instead of just one, with each entry
corresponding to an independent sprite.  For each sprite, there is a vertical and horizontal
position (relative to the upper left corner of the screen minus 128 pixels in each direction), the
size of the sprite in cells (a single sprite can be comprised of up to 4 x 4 cells), the pattern
name to use for the first cell (in the same format as the scrolls), and a link number.  The
organization of a sprite entry is more clearly displayed
<a href="https://wiki.megadrive.org/index.php?title=VDP_Sprites">here</a></p>
<p>The link number is used to determine the sprite priority.  Sprite 0, which is the first entry in the
table, is always the highest priority sprite.  Its link number is the index in the sprite table for
the next highest priority sprite, which could be anywhere in the sprite table.  That sprite's link
number would then point to the next highest priority sprite and so on until a sprite has a link
number of 0.  When multiple sprites are on top of each other, the highest priority sprite will
appear on top.</p>
<p align="center">
<img src="images/2022-01/sonic2-scroll-breakdown.png" title="A breakdown of the screen planes in Sonic 2" />
</p>

<p>This shows the breakdown of the different planes that are combined to form the final output.  From
the top left to the bottom right is Scroll B (the background), Scroll A (the foreground), the
Sprites (the moveable graphics), and then the final image is the three planes combined.</p>
<p>The following code is my first attempt at implementing this.  (Please note: this code contains many
issues but it wasn't until after much debugging that I figured out what they all were.  I'd like to
describe the process of debugging this code in Part III, so I'm showing the code that I started with
here.  Bonus points to anyone who can figure out the bugs without reading onward).</p>
<div class="codehilite"><pre><span></span><code><span class="k">pub</span><span class="w"> </span><span class="k">fn</span><span class="w"> </span><span class="nf">draw_frame</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">frame</span><span class="p">:</span><span class="w"> </span><span class="kp">&amp;</span><span class="nc">mut</span><span class="w"> </span><span class="n">Frame</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="bp">self</span><span class="p">.</span><span class="n">draw_background</span><span class="p">(</span><span class="n">frame</span><span class="p">);</span>
<span class="w">    </span><span class="bp">self</span><span class="p">.</span><span class="n">draw_cell_table</span><span class="p">(</span><span class="n">frame</span><span class="p">,</span><span class="w"> </span><span class="p">((</span><span class="bp">self</span><span class="p">.</span><span class="n">regs</span><span class="p">[</span><span class="n">REG_SCROLL_B_ADDR</span><span class="p">]</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="kt">u16</span><span class="p">)</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="mi">13</span><span class="p">)</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="kt">u32</span><span class="p">);</span>
<span class="w">    </span><span class="bp">self</span><span class="p">.</span><span class="n">draw_cell_table</span><span class="p">(</span><span class="n">frame</span><span class="p">,</span><span class="w"> </span><span class="p">((</span><span class="bp">self</span><span class="p">.</span><span class="n">regs</span><span class="p">[</span><span class="n">REG_SCROLL_A_ADDR</span><span class="p">]</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="kt">u16</span><span class="p">)</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="mi">10</span><span class="p">)</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="kt">u32</span><span class="p">);</span>
<span class="w">    </span><span class="bp">self</span><span class="p">.</span><span class="n">draw_sprites</span><span class="p">(</span><span class="n">frame</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">fn</span><span class="w"> </span><span class="nf">draw_background</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">frame</span><span class="p">:</span><span class="w"> </span><span class="kp">&amp;</span><span class="nc">mut</span><span class="w"> </span><span class="n">Frame</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">bg_colour</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="n">get_palette_colour</span><span class="p">((</span><span class="bp">self</span><span class="p">.</span><span class="n">regs</span><span class="p">[</span><span class="n">REG_BACKGROUND</span><span class="p">]</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="mh">0x30</span><span class="p">)</span><span class="w"> </span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="mi">4</span><span class="p">,</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="n">regs</span><span class="p">[</span><span class="n">REG_BACKGROUND</span><span class="p">]</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="mh">0x0f</span><span class="p">);</span>
<span class="w">    </span><span class="n">frame</span><span class="p">.</span><span class="n">clear</span><span class="p">(</span><span class="n">bg_colour</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">fn</span><span class="w"> </span><span class="nf">draw_cell_table</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">frame</span><span class="p">:</span><span class="w"> </span><span class="kp">&amp;</span><span class="nc">mut</span><span class="w"> </span><span class="n">Frame</span><span class="p">,</span><span class="w"> </span><span class="n">cell_table</span><span class="p">:</span><span class="w"> </span><span class="kt">u32</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="p">(</span><span class="n">scroll_h</span><span class="p">,</span><span class="w"> </span><span class="n">scroll_v</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="n">get_scroll_size</span><span class="p">();</span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="p">(</span><span class="n">cells_h</span><span class="p">,</span><span class="w"> </span><span class="n">cells_v</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="n">get_screen_size</span><span class="p">();</span>

<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="n">cell_y</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="mi">0</span><span class="o">..</span><span class="n">cells_v</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">for</span><span class="w"> </span><span class="n">cell_x</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="mi">0</span><span class="o">..</span><span class="n">cells_h</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="kd">let</span><span class="w"> </span><span class="n">pattern_name</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">read_beu16</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">.</span><span class="n">vram</span><span class="p">[(</span><span class="n">cell_table</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="p">((</span><span class="n">cell_x</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="p">(</span><span class="n">cell_y</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">scroll_h</span><span class="p">))</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="kt">u32</span><span class="p">)</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="kt">usize</span><span class="o">..</span><span class="p">]);</span>
<span class="w">            </span><span class="kd">let</span><span class="w"> </span><span class="n">iter</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="n">get_pattern_iter</span><span class="p">(</span><span class="n">pattern_name</span><span class="p">);</span>
<span class="w">            </span><span class="n">frame</span><span class="p">.</span><span class="n">blit</span><span class="p">((</span><span class="n">cell_x</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="mi">3</span><span class="p">)</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="kt">u32</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="n">cell_y</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="mi">3</span><span class="p">)</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="kt">u32</span><span class="p">,</span><span class="w"> </span><span class="n">iter</span><span class="p">,</span><span class="w"> </span><span class="mi">8</span><span class="p">,</span><span class="w"> </span><span class="mi">8</span><span class="p">);</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>

<span class="k">fn</span><span class="w"> </span><span class="nf">build_link_list</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">sprite_table</span><span class="p">:</span><span class="w"> </span><span class="kt">usize</span><span class="p">,</span><span class="w"> </span><span class="n">links</span><span class="p">:</span><span class="w"> </span><span class="kp">&amp;</span><span class="nc">mut</span><span class="w"> </span><span class="p">[</span><span class="kt">usize</span><span class="p">])</span><span class="w"> </span><span class="p">-&gt;</span><span class="w"> </span><span class="kt">usize</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">links</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">    </span><span class="k">loop</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">link</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="n">vram</span><span class="p">[</span><span class="n">sprite_table</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="p">(</span><span class="n">links</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">8</span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">3</span><span class="p">];</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="n">link</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="n">link</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">80</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="k">break</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">        </span><span class="n">i</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="w">        </span><span class="n">links</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">link</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="kt">usize</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="n">i</span>
<span class="p">}</span>

<span class="k">fn</span><span class="w"> </span><span class="nf">draw_sprites</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">frame</span><span class="p">:</span><span class="w"> </span><span class="kp">&amp;</span><span class="nc">mut</span><span class="w"> </span><span class="n">Frame</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">sprite_table</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="bp">self</span><span class="p">.</span><span class="n">regs</span><span class="p">[</span><span class="n">REG_SPRITES_ADDR</span><span class="p">]</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="kt">usize</span><span class="p">)</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="mi">9</span><span class="p">;</span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="p">(</span><span class="n">cells_h</span><span class="p">,</span><span class="w"> </span><span class="n">cells_v</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="n">get_screen_size</span><span class="p">();</span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="p">(</span><span class="n">pos_limit_h</span><span class="p">,</span><span class="w"> </span><span class="n">pos_limit_v</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="k">if</span><span class="w"> </span><span class="n">cells_h</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">32</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="mi">383</span><span class="w"> </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="mi">447</span><span class="w"> </span><span class="p">},</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="n">cells_v</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">28</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="mi">351</span><span class="w"> </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="mi">367</span><span class="w"> </span><span class="p">});</span>

<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">links</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="mi">80</span><span class="p">];</span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">lowest</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="n">build_link_list</span><span class="p">(</span><span class="n">sprite_table</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="n">links</span><span class="p">);</span>

<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="p">(</span><span class="mi">0</span><span class="o">..</span><span class="n">lowest</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">).</span><span class="n">rev</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">sprite_data</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="bp">self</span><span class="p">.</span><span class="n">vram</span><span class="p">[(</span><span class="n">sprite_table</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="p">(</span><span class="n">links</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">8</span><span class="p">))</span><span class="o">..</span><span class="p">];</span>

<span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">v_pos</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">read_beu16</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sprite_data</span><span class="p">[</span><span class="mi">0</span><span class="o">..</span><span class="p">]);</span>
<span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">size</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sprite_data</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
<span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">pattern_name</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">read_beu16</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sprite_data</span><span class="p">[</span><span class="mi">4</span><span class="o">..</span><span class="p">]);</span>
<span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">h_pos</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">read_beu16</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sprite_data</span><span class="p">[</span><span class="mi">6</span><span class="o">..</span><span class="p">]);</span>

<span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="p">(</span><span class="n">size_h</span><span class="p">,</span><span class="w"> </span><span class="n">size_v</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(((</span><span class="n">size</span><span class="w"> </span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="mi">2</span><span class="p">)</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="mh">0x03</span><span class="p">)</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="kt">u16</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="n">size</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="mh">0x03</span><span class="p">)</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="kt">u16</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span>
<span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">h_rev</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">pattern_name</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="mh">0x0800</span><span class="p">)</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">v_rev</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">pattern_name</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="mh">0x1000</span><span class="p">)</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>

<span class="w">        </span><span class="k">for</span><span class="w"> </span><span class="n">ih</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="mi">0</span><span class="o">..</span><span class="n">size_h</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="k">for</span><span class="w"> </span><span class="n">iv</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="mi">0</span><span class="o">..</span><span class="n">size_v</span><span class="w"> </span><span class="p">{</span>
<span class="w">                </span><span class="kd">let</span><span class="w"> </span><span class="p">(</span><span class="n">h</span><span class="p">,</span><span class="w"> </span><span class="n">v</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="k">if</span><span class="w"> </span><span class="o">!</span><span class="n">h_rev</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">ih</span><span class="w"> </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">size_h</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">ih</span><span class="w"> </span><span class="p">},</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="o">!</span><span class="n">v_rev</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">iv</span><span class="w"> </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">size_v</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">iv</span><span class="w"> </span><span class="p">});</span>
<span class="w">                </span><span class="kd">let</span><span class="w"> </span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">h_pos</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">h</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">8</span><span class="p">,</span><span class="w"> </span><span class="n">v_pos</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">v</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">8</span><span class="p">);</span>
<span class="w">                </span><span class="k">if</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">128</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">pos_limit_h</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">128</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">pos_limit_v</span><span class="w"> </span><span class="p">{</span>
<span class="w">                    </span><span class="kd">let</span><span class="w"> </span><span class="n">iter</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="n">get_pattern_iter</span><span class="p">(</span><span class="n">pattern_name</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="p">(</span><span class="n">h</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">size_v</span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">v</span><span class="p">);</span>

<span class="w">                    </span><span class="n">frame</span><span class="p">.</span><span class="n">blit</span><span class="p">(</span><span class="n">x</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="kt">u32</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">128</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="kt">u32</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">128</span><span class="p">,</span><span class="w"> </span><span class="n">iter</span><span class="p">,</span><span class="w"> </span><span class="mi">8</span><span class="p">,</span><span class="w"> </span><span class="mi">8</span><span class="p">);</span>
<span class="w">                </span><span class="p">}</span>
<span class="w">            </span><span class="p">}</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>

<span class="k">fn</span><span class="w"> </span><span class="nf">get_pattern_iter</span><span class="o">&lt;&#39;</span><span class="na">a</span><span class="o">&gt;</span><span class="p">(</span><span class="o">&amp;&#39;</span><span class="na">a</span><span class="w"> </span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">pattern_name</span><span class="p">:</span><span class="w"> </span><span class="kt">u16</span><span class="p">)</span><span class="w"> </span><span class="p">-&gt;</span><span class="w"> </span><span class="nc">PatternIterator</span><span class="o">&lt;&#39;</span><span class="na">a</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">pattern_addr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">pattern_name</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="mh">0x07FF</span><span class="p">)</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="mi">5</span><span class="p">;</span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">pattern_palette</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">((</span><span class="n">pattern_name</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="mh">0x6000</span><span class="p">)</span><span class="w"> </span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="mi">13</span><span class="p">)</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="kt">u8</span><span class="p">;</span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">h_rev</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">pattern_name</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="mh">0x0800</span><span class="p">)</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">v_rev</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">pattern_name</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="mh">0x1000</span><span class="p">)</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">    </span><span class="n">PatternIterator</span><span class="p">::</span><span class="n">new</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">pattern_addr</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="kt">u32</span><span class="p">,</span><span class="w"> </span><span class="n">pattern_palette</span><span class="p">,</span><span class="w"> </span><span class="n">h_rev</span><span class="p">,</span><span class="w"> </span><span class="n">v_rev</span><span class="p">)</span>
<span class="p">}</span>

<span class="k">fn</span><span class="w"> </span><span class="nf">get_scroll_size</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span><span class="p">-&gt;</span><span class="w"> </span><span class="p">(</span><span class="kt">u16</span><span class="p">,</span><span class="w"> </span><span class="kt">u16</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">h</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">scroll_size</span><span class="p">(</span><span class="bp">self</span><span class="p">.</span><span class="n">regs</span><span class="p">[</span><span class="n">REG_SCROLL_SIZE</span><span class="p">]</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="mh">0x03</span><span class="p">);</span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">v</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">scroll_size</span><span class="p">((</span><span class="bp">self</span><span class="p">.</span><span class="n">regs</span><span class="p">[</span><span class="n">REG_SCROLL_SIZE</span><span class="p">]</span><span class="w"> </span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="mi">4</span><span class="p">)</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="mh">0x03</span><span class="p">);</span>
<span class="w">    </span><span class="p">(</span><span class="n">h</span><span class="p">,</span><span class="w"> </span><span class="n">v</span><span class="p">)</span>
<span class="p">}</span>

<span class="k">fn</span><span class="w"> </span><span class="nf">get_screen_size</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span><span class="p">-&gt;</span><span class="w"> </span><span class="p">(</span><span class="kt">u16</span><span class="p">,</span><span class="w"> </span><span class="kt">u16</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">h_cells</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="bp">self</span><span class="p">.</span><span class="n">regs</span><span class="p">[</span><span class="n">REG_MODE_SET_4</span><span class="p">]</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="n">MODE4_BF_H_CELL_MODE</span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="mi">32</span><span class="w"> </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="mi">40</span><span class="w"> </span><span class="p">};</span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">v_cells</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="bp">self</span><span class="p">.</span><span class="n">regs</span><span class="p">[</span><span class="n">REG_MODE_SET_2</span><span class="p">]</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="n">MODE2_BF_V_CELL_MODE</span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="mi">28</span><span class="w"> </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="mi">30</span><span class="w"> </span><span class="p">};</span>
<span class="w">    </span><span class="p">(</span><span class="n">h_cells</span><span class="p">,</span><span class="w"> </span><span class="n">v_cells</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div>

<p>And after running this with the Sonic 1 ROM, I'm greeted by...</p>
<p align="center">
<img src="images/2022-01/sonic1-broken-oct-26.png" title="Sonic 1 broken SEGA screen" />
</p>

<p>Well it kinda looks like the SEGA logo but why are the colours so wrong...</p>
<h2 id="next-time">Next Time</h2>
<p>After about two weeks or so of working on the Sega Genesis support for Moa, reading up on the
internal workings of the console, implementing a simple swappable frontend, and implementing my
first best guess of how it should work, I could display a very mangled image with bright magenta
colours instead of blues.  To be honest, I was a bit dejected.  I was hoping to have something that
at least looked coherent before I added my work in progress to git.  Fiddling with it wasn't
improving matters at all, so it wasn't going to be a quick fix.  I was going to have roll up my
sleeves and grind it out.</p>
<p>This is where the real journey began, tirelessly debugging until I hit a wall, taking some detours,
working on other projects for a while, eventually returning to it, isolating the problems with the
help of some test ROMs and another Genesis emulator as a reference, and finally getting it working.
Stay tuned for the (not so) thrilling conclusion in <a href="https://jabberwocky.ca/posts/2022-01-emulating_the_sega_genesis_part3.html">Part
III</a> of Emulating The
Sega Genesis.</p>

    </div>
    <div id="footer">
        <hr>
        Made with <a href="../generate.py">Python</a>
        <div class="email">trans@jabberwocky.ca</div>
    </div>
</div>
</body>
</html>

