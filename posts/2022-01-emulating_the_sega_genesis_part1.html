<!DOCTYPE html>
<html>
<head>
    <title>Emulating the Sega Genesis - Part I</title>

    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="description" content="transistorfet's website" />
    <meta name="author" content="transistor fet" />
    <meta name="keywords" content="jabberwocky, transistorfet, programming, electronics, rust, m68k, z80, sega, genesis, megadrive, trs80, emulator" />

    <link rel="canonical" href="https://jabberwocky.ca/posts/2022-01-emulating_the_sega_genesis_part1.html" />

    <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Recursive" type="text/css" charset="utf-8" />
    <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=IBM+Plex+Mono" type="text/css" charset="utf-8" />
    <link rel="stylesheet" href="../assets/normalize.css" type="text/css" charset="utf-8" />
    <link rel="stylesheet" href="../assets/layout.css" type="text/css" charset="utf-8" />
    <link id="pagetheme" rel="stylesheet" href="../assets/theme-light.css" type="text/css" charset="utf-8" />
    <link id="codetheme" rel="stylesheet" href="../assets/code-default.css" type="text/css" charset="utf-8" />
    <script src="../assets/theme.js"></script>
</head>
<body>
<div id="main">

    <div id="theme-toggle"></div>

    <div id="menu-toggle">&#x2630;</div>
    <input class="toggle-trigger" type="checkbox" checked />
    <div id="sidebar" class="toggle">
        <a href="../"><h2>Projects</h2></a>
        <hr>

<ul class="projects">
<li><a href="../projects/computie/">Computie 68k</a></li>
<li><a href="../projects/molten/">Molten</a></li>
<li><a href="../projects/moa/">Moa Emulator</a></li>
<li><a href="../projects/ruxpin/">Ruxpin OS</a></li>
<li><a href="../projects/fidget/">Fidget</a></li>
<li><a href="../projects/z280/">Z280 Computer</a></li>
<li><a href="../projects/gloworm/">Gloworm OS</a></li>
<li><a href="../projects/nerve/">Nerve Control Network</a></li>
<li><a href="../projects/deskclock2/">DeskClock2</a></li>
<li><a href="../projects/rgbnode/">RGB Node</a></li>
<li><a href="../projects/rgbnode-rs/">RGB Node with Rust</a></li>
<li><a href="../projects/webmush/">WebMUSH</a></li>
<li><a href="../projects/conlog/">Conlog</a></li>
<li><a href="../projects/fallingrust/">Falling Rust</a></li>
<li><a href="../projects/abugslife/">A Bug's Life</a></li>
<li><a href="../projects/acamlslife/">A Caml's Life</a></li>
<li><a href="../projects/synthetik/">Synthetik Synth</a></li>
<li><a href="../projects/meteorman/">Meteor Games</a></li>
<li><a href="../projects/logarithm/">Logarithm IRC Bot</a></li>
<li><a href="../projects/sdm/">Super Duper Moo</a></li>
<li><a href="../projects/sdrl/">SDRL Interpreter</a></li>
<li><a href="../projects/stutter/">Stutter IRC Client</a></li>
</ul>
<hr>
<h3>Posts</h3>
<ul class="posts">
<li><a href="../posts/2022-01-emulating_the_sega_genesis_part3.html">Emulating the Sega Genesis - Part III</a></li>
<li><a href="../posts/2022-01-emulating_the_sega_genesis_part2.html">Emulating the Sega Genesis - Part II</a></li>
<li><a href="../posts/2022-01-emulating_the_sega_genesis_part1.html">Emulating the Sega Genesis - Part I</a></li>
<li><a href="../posts/2021-11-making_an_emulator.html">Making a 68000 Emulator in Rust</a></li>
<li><a href="../posts/2021-09-bootstrapping_with_arduino.html">Bootstrapping a Homebuilt Computer Using An Arduino</a></li>
<li><a href="../posts/2021-08-molten_overview.html">An Overview Of Molten Internals</a></li>
</ul>


        <hr>
        <a href="https://github.com/transistorfet"><img class="icon" src="../assets/icons/github.svg"></a>
        <a href="https://bsky.app/profile/transistorfet.bsky.social"><img class="icon" src="../assets/icons/bluesky.svg"></a>
        <a href="https://mastodon.social/@transistor_fet"><img class="icon" src="../assets/icons/mastodon.svg"></a>
        <a href="https://twitch.tv/transistorfet"><img class="icon" src="../assets/icons/twitch.svg"></a>
        <a href="https://youtube.com/@transistorfet"><img class="icon" src="../assets/icons/youtube.svg"></a>
        <a href="https://dev.to/transistorfet"><img class="icon" src="../assets/icons/dev-badge.svg"></a>
        <a href="mailto:trans@jabberwocky.ca"><img class="icon" src="../assets/icons/email.svg"></a>
        <a href="https://linkedin.com/in/sarimcfarland"><img class="icon" src="../assets/icons/linkedin.svg"></a>
    </div>
    <div id="content">

<h1 id="emulating-the-sega-genesis-part-i">Emulating the Sega Genesis - Part I</h1>
<p><em>Also available on <a href="https://dev.to/transistorfet/emulating-the-sega-genesis-part-i-1ao5">dev.to</a></em></p>
<h6 id="written-december-2021january-2022-by-transistor_fet"><em>Written December 2021/January 2022 by transistor_fet</em></h6>
<p>A few months ago, I wrote a 68000 emulator in Rust named
<a href="https://jabberwocky.ca/projects/moa/">Moa</a>.  My original goal was to emulate a simple
<a href="https://jabberwocky.ca/projects/computie/">computer</a> I had previously built.  After only a few
weeks, I had that software up and running in the emulator, and my attention turned to what other
platforms with 68000s I could try emulating.  My thoughts quickly turned to the Sega Genesis and
without thinking about it too much, I dove right in.  What started as an unserious half-thought of
"wouldn't that be cool" turned into a few months of fighting documentation, game programming hacks,
and my sanity with some side quests along the way, all in the name of finding and squashing bugs in
the 68k emulator I had already written.</p>
<p>If you haven't already, you might want to read <a href="https://jabberwocky.ca/posts/2021-11-making_an_emulator.html">Making a 68000 Emulator in
Rust</a> where I talk about the basic
structure and function of the emulator, as well as details about the 68000.  I wont go into too much
detail about that here and instead focus on the Genesis-specific hardware, and the challenges of
debugging the emulator itself.</p>
<p>This is Part I in the series, which covers setting up the emulator, getting some game ROMs to run,
and implementing the DMA and memory features of the VDP.  <a href="https://jabberwocky.ca/posts/2022-01-emulating_the_sega_genesis_part2.html">Part
II</a> will cover adding a
graphical frontend to Moa, and then implementing a first attempt at generating video output.  <a href="https://jabberwocky.ca/posts/2022-01-emulating_the_sega_genesis_part3.html">Part
III</a> will be about
debugging the various problems in the VDP and CPU implementations to get a working emulator capable
of playing games.</p>
<ul>
<li><a href="#the-start">The Start</a></li>
<li><a href="#sega-genesis-mega-drive">Sega Genesis/Mega Drive</a></li>
<li><a href="#the-games">The Games</a></li>
<li><a href="#diving-in">Diving In</a></li>
<li><a href="#dummy-devices">Dummy Devices</a></li>
<li><a href="#memory-and-dma">Memory and DMA</a></li>
<li><a href="#talking-to-the-vdp">Talking To The VDP</a></li>
<li><a href="#implementing-the-memory-ops">Implementing The Memory Ops</a></li>
<li><a href="#next-time">Next Time</a></li>
</ul>
<h2 id="the-start">The Start</h2>
<p>Before starting Moa, I had never tried to make an emulator, but I have worked on projects with some
similarities such as interpreters, artificial life simulators, and some simple games.  I had been
looking for a fun distracting project, so I was approaching this as a fun challenge.  Especially
with the Genesis support, I wanted to get something up and running fast, just to see if it would
work at all, so rather than taking my more usual measured approach, I was working fast and loose to
get a proof of concept running.  I could always go back and fix things later, right?</p>
<p>I was primarily hoping to simulate the video chip in the Sega Genesis, enough to see the intended
graphics output and play the games.  Not only would it be a nice accomplishment to get some visual
feedback, but I would have to work out a way of creating a separate frontend that could display
graphics to a host window, which I could use for other systems as well.  I was less concerned with
audio, since that would require getting the Z80 working, which wasn't even on my horizon at the
time.  I was hoping that I could get away with just the 68k for now (which is certainly possible for
some but not all games).</p>
<h2 id="sega-genesismega-drive">Sega Genesis/Mega Drive</h2>
<p align="center">
<img src="images/2022-01/sega-genesis.jpg" title="Sega Genesis" />
</p>
<p>(From Wikipedia by Evan-Amos, used under the Creative Commons license.)</p>
<p>The <a href="https://segaretro.org/Sega_Mega_Drive">Sega Genesis</a> (also known as the Mega Drive outside of
North America) was released in 1988/1989 as a successor to the popular Sega Master System.  It's
main processor is a 68000 clocked at just under 8 MHz, which compared to computers of the time was
pretty outdated, but it's slower speed is compensated by the custom video display processor (VDP),
as well as a Z80 coprocessor, both of which can offload work from the 68000.  While the 68000 can
address up to 16 MB, it only has 64KB of main RAM, located at address <code>0xFF0000</code>.  The VDP (also
known by the part number of the chip, YM7101) has it's own separate 64KB of RAM which is only
accessible through the VDP, either by writing data to the VDP's ports, or configuring a DMA (direct
memory access) transfer from main memory to video memory, which is performed by the VDP.  Game
cartridges are mapped to address <code>0</code> of the 68000's address space, and can be up to 4MB.  It also
has two sound generation chips, the SN76489 and YM2612, but I don't have audio working yet so I wont
talk much about these.</p>
<p>The Genesis was one of the first video game consoles to have some backwards compatibility with it's
predecessor, although a <a href="https://segaretro.org/Power_Base_Converter">special pin-converter</a> was
needed in order to plug Master System cartridges into the Genesis.  In order to accomplish this, the
Genesis has a Z80 processor (in addition to the main 68000 processor), which can run on it's own
with it's own bus and memory.  It only has 2 KB of RAM instead of the 24 KB of the Master System,
but the 68000's address space can be mapped into a banked area that the Z80 can access.  While some
games work fine without the Z80 present, others will wait for certain data to be written by the Z80
before proceeding, which results in the game hanging.</p>
<p>The VDP or Video Display Processor is the central peripheral device in the console.  It generates
the video output signal, controls the video memory, handles DMA (Direct Memory Access) to transfer
data to the video memory, as well as handling all the interrupts in the system (there are 3, one
each for the horizontal and vertical blanking, and one for the game controllers).  It has it's own
64KB of video memory (VRAM) which holds all the graphics and data tables that describe which
graphics should be displayed and where on the screen.  Internal to the VDP there is also the colour
ram (CRAM), and vertical scroll ram (VSRAM), which have their own separate address spaces, and hold
the colour palettes and vertical cell offset numbers respectively.  In addition, there are 22
internal 8-bit registers which configure how the VDP behaves, which can only be accessed indirectly
through the memory-mapped interface to the VDP.  They control the graphics mode to use, the size of
the scrollable planes, the locations in VRAM of the scroll and sprite tables, the length and source
address to use for DMA transfers, and a few other things.</p>
<h2 id="the-games">The Games</h2>
<p>I'll mostly refer to "Sonic The Hedgehog 2" in examples because in the end, it's the game that
worked the best, even though I actually started with Sonic 1.  During development, I also tried
Earthworm Jim, Ren and Stimpy's Invention, and a few others that didn't work as well.  It wasn't
until I took a break and came back to it that I found <a href="https://www.mode5.net/#">ComradeOj's demos and test
ROMs</a>, which where much easier to test with.</p>
<p>In order to better trace the ROM's execution, the <code>.bin</code> ROM images can be disassembled using
m68k-gcc's objdump command:</p>
<div class="codehilite"><pre><span></span><code>m68k-linux-gnu-objdump -b binary -m m68k:68000 -D binaries/genesis/Sonic2.bin &gt; Sonic2.asm
</code></pre></div>

<p>One of the nice things about working with the 68000 is that it's still a supported architecture in
the latest version of gcc, so all the latest gcc tools can be used to compile and inspect binaries.
It's uncertain how much longer that will be the case, but that said, support was recently added to
LLVM and experimental support is available in Rust, so who knows.  Maybe there's still a long life
ahead for the 68000 architecture.</p>
<h2 id="diving-in">Diving In</h2>
<p>The first thing to sort out was the format of Sega Genesis game ROMs.  Some ROMs use a flat binary
format which can be directly loaded at address <code>0</code> without any changes or special parsing.  Other
ROMs use a format with the file extension <code>.smd</code> which interleaves the even- and odd-addressed bytes
of the ROM in 16 KB chunks, but there are utilities available that convert from <code>.smd</code> to <code>.bin</code>
format.  Since I was hoping to focus my attention on simulating the VDP, I chose to just use the
binary format for ROMs since the emulator can already load flat binaries, and I can use the
available conversion utilities to convert any <code>.smd</code> ROMs I had into <code>.bin</code> ROMs.</p>
<p>That was easier than I was expecting.  All I had to do was load the ROM file into a <code>MemoryBlock</code>
object in the emulator, and map that object to address <code>0</code>.  I also needed 64 KB of RAM mapped to
addresses 0xFF0000 through 0xFFFFFF, which also uses a <code>MemoryBlock</code>.  My Moa machine definition
looked something like this:</p>
<div class="codehilite"><pre><span></span><code><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">system</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">System</span><span class="p">::</span><span class="n">new</span><span class="p">();</span>

<span class="kd">let</span><span class="w"> </span><span class="n">rom</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">MemoryBlock</span><span class="p">::</span><span class="n">load</span><span class="p">(</span><span class="s">&quot;binaries/genesis/Sonic2.bin&quot;</span><span class="p">).</span><span class="n">unwrap</span><span class="p">();</span>
<span class="n">system</span><span class="p">.</span><span class="n">add_addressable_device</span><span class="p">(</span><span class="mh">0x00000000</span><span class="p">,</span><span class="w"> </span><span class="n">wrap_transmutable</span><span class="p">(</span><span class="n">rom</span><span class="p">)).</span><span class="n">unwrap</span><span class="p">();</span>

<span class="kd">let</span><span class="w"> </span><span class="n">ram</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">MemoryBlock</span><span class="p">::</span><span class="n">new</span><span class="p">(</span><span class="fm">vec!</span><span class="p">[</span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="mh">0x00010000</span><span class="p">]);</span>
<span class="n">system</span><span class="p">.</span><span class="n">add_addressable_device</span><span class="p">(</span><span class="mh">0x00FF0000</span><span class="p">,</span><span class="w"> </span><span class="n">wrap_transmutable</span><span class="p">(</span><span class="n">ram</span><span class="p">)).</span><span class="n">unwrap</span><span class="p">();</span>

<span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">cpu</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">M68k</span><span class="p">::</span><span class="n">new</span><span class="p">(</span><span class="n">M68kType</span><span class="p">::</span><span class="n">MC68000</span><span class="p">,</span><span class="w"> </span><span class="mi">7_670_454</span><span class="p">);</span>
<span class="n">cpu</span><span class="p">.</span><span class="n">enable_tracing</span><span class="p">();</span>
<span class="n">system</span><span class="p">.</span><span class="n">add_device</span><span class="p">(</span><span class="s">&quot;cpu&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">wrap_transmutable</span><span class="p">(</span><span class="n">cpu</span><span class="p">)).</span><span class="n">unwrap</span><span class="p">();</span>

<span class="nb">Ok</span><span class="p">(</span><span class="n">system</span><span class="p">)</span>
</code></pre></div>

<p>Running this gave the results:</p>
<div class="codehilite"><pre><span></span><code>0x00000206: 4ab9 00a1 0008 
        tstl    (#00a10008)

Status: Running
PC: 0x0000020c
SR: 0x2700
D0: 0x00000000        A0:  0x00000000
D1: 0x00000000        A1:  0x00000000
D2: 0x00000000        A2:  0x00000000
D3: 0x00000000        A3:  0x00000000
D4: 0x00000000        A4:  0x00000000
D5: 0x00000000        A5:  0x00000000
D6: 0x00000000        A6:  0x00000000
D7: 0x00000000
SSP: 0xfffffe00
USP: 0x00000000
Current Instruction: 0x00000206 TST(IndirectMemory(10551304), Long)

0x00fffe00: 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 
0x00fffe10: 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 
0x00fffe20: 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 
0x00fffe30: 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 

Error { err: Emulator, native: 0, msg: &quot;No segment found at 0xa10008&quot; }
thread &#39;main&#39; panicked at &#39;called `Result::unwrap()` on an `Err` value: Error { err: Emulator, native: 0, msg: &quot;No segment found at 0xa10008&quot; }&#39;, frontends/moa-minifb/src/lib.rs:70:40
</code></pre></div>

<p>Wow, It worked! (sort of).  The first line of the output shows the address of the instruction being
executed (<code>0x206</code>), followed by the instruction data that was decoded.  Below that is the decoded
instruction in assembly notation.  When an error occurs, Moa will dump the values of the CPU
registers along with a dump of the stack area, which in this case is located at address <code>0xfffe00</code>.
The <code>tstl (#0xa10008)</code> instruction that's being executed is supposed to compare the value stored at
the address <code>0xa10008</code> to zero, and set the flags in the <code>%sr</code> register accordingly.  The error that
occurs means there was an attempt to access address <code>0xa10008</code>, which isn't mapped to a valid area
on the data bus, and Moa is currently configured to cause a fatal error in that case.</p>
<p>According to the <a href="https://segaretro.org/Sega_Mega_Drive/Memory_map">memory map</a> for the Genesis, the
address <code>0xa10008</code> is the control port for Controller 1, which makes sense.  It's doing something
that would be expected of a Genesis ROM, even if it only gets one instruction in before dying.</p>
<p>Taking a look at the first 16 bytes of the ROM shows:</p>
<div class="codehilite"><pre><span></span><code>00000000:  FF FF FE 00 00 00 02 06 00 00 02 00 00 00 02 00
</code></pre></div>

<p>The first 4 bytes are the stack pointer (<code>0xfffffe00</code>) and the next 4 bytes are the reset address,
which is the same address as the starting instruction, <code>0x206</code>.  (If your curious, the two addresses
that follow the reset address are for the bus error and address error handlers respectively, which
point to the same handler at <code>0x200</code>).</p>
<p>You may have noticed that the stack pointer value (<code>0xfffffe00</code>) is a full 32-bit address, but the
68000 only supports 24-bit addresses.  In hardware, the extra 8-bits at the top (ie. <code>0xff</code>) would
be ignored.  I had to modify the emulator to allow an address mask to be configured, so that all
32-bit addresses coming from the 68000 are masked to only 24-bits.  I eventually made a more
complete and configurable solution that's described later.</p>
<p>To get around the no segment found error, I added another memory block for 0xa10000 in order to
prevent the error, and now a handful of instructions are running correctly until the next "No
segment found" error occurs.</p>
<div class="codehilite"><pre><span></span><code>0x00000206: 4ab9 00a1 0008 
        tstl    (#00a10008)

0x0000020c: 6606 
        bne     6

0x0000020e: 4a79 00a1 000c 
        tstw    (#00a1000c)

0x00000214: 667c 
        bne     124

0x00000216: 4bfa 007c 
        lea     (%pc + #007c), %a5

0x0000021a: 4c9d 00e0 
        movemw  (%a5)+, %d5-%d7

0x0000021e: 4cdd 1f00 
        moveml  (%a5)+, %a0-%a4

0x00000222: 1029 ef01 
        moveb   (%a1 + #ffffef01), %d0

0x00000226: 0200 000f 
        andb    #0000000f, %d0

0x0000022a: 6708 
        beq     8

0x00000234: 3014 
        movew   (%a4), %d0

Status: Running
PC: 0x00000236
SR: 0x2704
D0: 0x00000000        A0:  0x00a00000
D1: 0x00000000        A1:  0x00a11100
D2: 0x00000000        A2:  0x00a11200
D3: 0x00000000        A3:  0x00c00000
D4: 0x00000000        A4:  0x00c00004
D5: 0xffff8000        A5:  0x000002ae
D6: 0x00003fff        A6:  0x00000000
D7: 0x00000100
SSP: 0xfffffe00
USP: 0x00000000
Current Instruction: 0x00000234 MOVE(IndirectAReg(4), DirectDReg(0), Word)

0xfffffe00: 

Error { err: Emulator, native: 0, msg: &quot;No segment found at 0xc00004&quot; }
</code></pre></div>

<p>Another missing I/O device.  The <code>0xc00004</code> address is the control port of the VDP, so again that
makes sense.  Adding another <code>MemoryBlock</code> for that address range prevents the emulator from hitting
another error, but it instead gets stuck in a loop.</p>
<div class="codehilite"><pre><span></span><code>0x0000024c: 3287 
        movew   %d7, (%a1)

0x0000024e: 3487 
        movew   %d7, (%a2)

0x00000250: 0111 
        btstb   %d0, (%a1)

0x00000252: 66fc 
        bne     -4

0x00000250: 0111 
        btstb   %d0, (%a1)

0x00000252: 66fc 
        bne     -4

0x00000250: 0111 
        btstb   %d0, (%a1)

0x00000252: 66fc 
        bne     -4
...
</code></pre></div>

<p>The register <code>%a1</code> has the value <code>0xa11100</code>, <code>%d0</code> has <code>0x00</code>, and <code>%d7</code> has <code>0x0100</code>.  The code
first writes the value <code>0x0100</code> to address <code>0xa11100</code>, and then tests if the bit that was just set
at that memory location is 1.  It then loops back to the bit test instruction until it becomes 0,
which never happens because that address is just a memory location at the moment, and not an I/O
device.  That address, according to the map, is the Z80 bus request location for enabling or
disabling the bus request pin on the Z80.</p>
<p>At this point I'll need to start properly implementing the devices at these address locations in
order to get further in the execution of a program.  It's only executed a hundred or so instructions
to get to this infinite loop, which isn't very much, but this is very promising.</p>
<h2 id="dummy-devices">Dummy Devices</h2>
<p>In order to get the game ROMs to run further, I needed some basic devices that can respond to the
addresses of the various peripherals.  It was just a matter of looking through the <a href="https://segaretro.org/Sega_Mega_Drive/Memory_map">memory
map</a> and filling in the gaps.  The Sega CD and 32X
devices could be ignored, since I was only working on basic Genesis support for now, but the rest
will need to respond in some way, so they will need to be assigned to Moa devices.</p>
<p>To start with, there is a 64KB chunk of addresses at <code>0xa00000</code> for accessing the Z80's address space,
which can be filled with a <code>MemoryBlock</code> for now.</p>
<p>Then there's a chunk of 0x20 addresses starting at <code>0xa10000</code>, which are mostly related to the
controllers.  An exception to that is the special version register at the start of that range.  It's
supposed to always return a constant value to indicate which hardware version of the console the ROM
is running on.  I can just add that location to the same device as the controllers to make it easy.
I'll need a <code>Transmutable</code> object to represent all the controllers.</p>
<div class="codehilite"><pre><span></span><code><span class="k">pub</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">GenesisControllerPort</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="n">data</span><span class="p">:</span><span class="w"> </span><span class="kt">u16</span><span class="p">,</span>
<span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="n">ctrl</span><span class="p">:</span><span class="w"> </span><span class="kt">u8</span><span class="p">,</span>
<span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="n">th_count</span><span class="p">:</span><span class="w"> </span><span class="kt">u8</span><span class="p">,</span>
<span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="n">next_read</span><span class="p">:</span><span class="w"> </span><span class="kt">u8</span><span class="p">,</span>
<span class="p">}</span>

<span class="k">pub</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">GenesisControllers</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="n">port_1</span><span class="p">:</span><span class="w"> </span><span class="nc">GenesisControllerPort</span><span class="p">,</span>
<span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="n">port_2</span><span class="p">:</span><span class="w"> </span><span class="nc">GenesisControllerPort</span><span class="p">,</span>
<span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="n">expansion</span><span class="p">:</span><span class="w"> </span><span class="nc">GenesisControllerPort</span><span class="p">,</span>
<span class="p">}</span>

<span class="k">impl</span><span class="w"> </span><span class="n">Addressable</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">GenesisControllers</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">fn</span><span class="w"> </span><span class="nf">len</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span><span class="p">-&gt;</span><span class="w"> </span><span class="kt">usize</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="mh">0x20</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="k">fn</span><span class="w"> </span><span class="nf">read</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">addr</span><span class="p">:</span><span class="w"> </span><span class="nc">Address</span><span class="p">,</span><span class="w"> </span><span class="n">data</span><span class="p">:</span><span class="w"> </span><span class="kp">&amp;</span><span class="nc">mut</span><span class="w"> </span><span class="p">[</span><span class="kt">u8</span><span class="p">])</span><span class="w"> </span><span class="p">-&gt;</span><span class="w"> </span><span class="nb">Result</span><span class="o">&lt;</span><span class="p">(),</span><span class="w"> </span><span class="n">Error</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="c1">// If the address is even, only the second byte (odd byte) will be meaningful</span>
<span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">addr</span><span class="w"> </span><span class="o">%</span><span class="w"> </span><span class="mi">2</span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="n">addr</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="w">            </span><span class="n">i</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span>

<span class="w">        </span><span class="k">match</span><span class="w"> </span><span class="n">addr</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="n">REG_VERSION</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">0xA0</span><span class="p">;</span><span class="w"> </span><span class="p">}</span><span class="w"> </span><span class="c1">// Overseas Version, NTSC, No Expansion</span>
<span class="w">            </span><span class="n">REG_DATA1</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="n">port_1</span><span class="p">.</span><span class="n">next_read</span><span class="p">;</span><span class="w"> </span><span class="p">},</span>
<span class="w">            </span><span class="n">REG_DATA2</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="n">port_2</span><span class="p">.</span><span class="n">next_read</span><span class="p">;</span><span class="w"> </span><span class="p">},</span>
<span class="w">            </span><span class="n">REG_DATA3</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="n">expansion</span><span class="p">.</span><span class="n">next_read</span><span class="p">;</span><span class="w"> </span><span class="p">},</span>
<span class="w">            </span><span class="n">REG_CTRL1</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="n">port_1</span><span class="p">.</span><span class="n">ctrl</span><span class="p">;</span><span class="w"> </span><span class="p">},</span>
<span class="w">            </span><span class="n">REG_CTRL2</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="n">port_2</span><span class="p">.</span><span class="n">ctrl</span><span class="p">;</span><span class="w"> </span><span class="p">},</span>
<span class="w">            </span><span class="n">REG_CTRL3</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="n">expansion</span><span class="p">.</span><span class="n">ctrl</span><span class="p">;</span><span class="w"> </span><span class="p">},</span>
<span class="w">            </span><span class="n">_</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">warning</span><span class="o">!</span><span class="p">(</span><span class="s">&quot;{}: !!! unhandled reading from {:0x}&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">DEV_NAME</span><span class="p">,</span><span class="w"> </span><span class="n">addr</span><span class="p">);</span><span class="w"> </span><span class="p">},</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">        </span><span class="n">info</span><span class="o">!</span><span class="p">(</span><span class="s">&quot;{}: read from register {:x} the value {:x}&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">DEV_NAME</span><span class="p">,</span><span class="w"> </span><span class="n">addr</span><span class="p">,</span><span class="w"> </span><span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
<span class="w">        </span><span class="nb">Ok</span><span class="p">(())</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="k">fn</span><span class="w"> </span><span class="nf">write</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">addr</span><span class="p">:</span><span class="w"> </span><span class="nc">Address</span><span class="p">,</span><span class="w"> </span><span class="n">data</span><span class="p">:</span><span class="w"> </span><span class="kp">&amp;</span><span class="p">[</span><span class="kt">u8</span><span class="p">])</span><span class="w"> </span><span class="p">-&gt;</span><span class="w"> </span><span class="nb">Result</span><span class="o">&lt;</span><span class="p">(),</span><span class="w"> </span><span class="n">Error</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">info</span><span class="o">!</span><span class="p">(</span><span class="s">&quot;{}: write to register {:x} with {:x}&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">DEV_NAME</span><span class="p">,</span><span class="w"> </span><span class="n">addr</span><span class="p">,</span><span class="w"> </span><span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
<span class="w">        </span><span class="k">match</span><span class="w"> </span><span class="n">addr</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="n">REG_DATA1</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="n">port_1</span><span class="p">.</span><span class="n">set_data</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span><span class="w"> </span><span class="p">}</span>
<span class="w">            </span><span class="n">REG_DATA2</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="n">port_2</span><span class="p">.</span><span class="n">set_data</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span><span class="w"> </span><span class="p">},</span>
<span class="w">            </span><span class="n">REG_DATA3</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="n">expansion</span><span class="p">.</span><span class="n">set_data</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span><span class="w"> </span><span class="p">},</span>
<span class="w">            </span><span class="n">REG_CTRL1</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="n">port_1</span><span class="p">.</span><span class="n">ctrl</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span><span class="w"> </span><span class="p">},</span>
<span class="w">            </span><span class="n">REG_CTRL2</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="n">port_2</span><span class="p">.</span><span class="n">ctrl</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span><span class="w"> </span><span class="p">},</span>
<span class="w">            </span><span class="n">REG_CTRL3</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="n">expansion</span><span class="p">.</span><span class="n">ctrl</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span><span class="w"> </span><span class="p">},</span>
<span class="w">            </span><span class="n">_</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">warning</span><span class="o">!</span><span class="p">(</span><span class="s">&quot;{}: !!! unhandled write of {:0x} to {:0x}&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">DEV_NAME</span><span class="p">,</span><span class="w"> </span><span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="w"> </span><span class="n">addr</span><span class="p">);</span><span class="w"> </span><span class="p">},</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">        </span><span class="nb">Ok</span><span class="p">(())</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</code></pre></div>

<p>The next set of addresses are a bit clumsy unfortunately.  The addresses <code>0xa11000</code>, <code>0xa11100</code>, and
<code>0xa11200</code> are special registers used for controlling the Z80, and all other addresses in that range
are "prohibited" (not that that stops ROMs from accessing those areas, as I've found out, in
frustration).  <code>0xa11000</code> is used to configure DRAM mode for ROM development on the hardware, which
isn't needed here.  The other two locations control the Z80's reset and bus request lines
respectively.  The bus request signal will tell the Z80 to stop running and disconnect itself from
the memory bus, so that the 68000 can access the Z80's RAM directly.  Without this, the read and
writes could conflict with each other resulting in both CPUs reading or writing garbage.  This wont
reset the Z80, which will continue running where it left off, when the bus request signal is
de-asserted.  The reset signal allows the Z80 to be reset so that it starts in a known state.
Again, I'll need a custom <code>Transmutable</code> device to handle these locations, and the unmapped areas
will just return nothing.</p>
<div class="codehilite"><pre><span></span><code><span class="k">pub</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">CoprocessorControl</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="n">bus_request</span><span class="p">:</span><span class="w"> </span><span class="kt">bool</span><span class="p">,</span>
<span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="n">reset</span><span class="p">:</span><span class="w"> </span><span class="kt">bool</span><span class="p">,</span>
<span class="p">}</span>

<span class="k">impl</span><span class="w"> </span><span class="n">Addressable</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">CoprocessorControl</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">fn</span><span class="w"> </span><span class="nf">len</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span><span class="p">-&gt;</span><span class="w"> </span><span class="kt">usize</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="mh">0x4000</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="k">fn</span><span class="w"> </span><span class="nf">read</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">addr</span><span class="p">:</span><span class="w"> </span><span class="nc">Address</span><span class="p">,</span><span class="w"> </span><span class="n">data</span><span class="p">:</span><span class="w"> </span><span class="kp">&amp;</span><span class="nc">mut</span><span class="w"> </span><span class="p">[</span><span class="kt">u8</span><span class="p">])</span><span class="w"> </span><span class="p">-&gt;</span><span class="w"> </span><span class="nb">Result</span><span class="o">&lt;</span><span class="p">(),</span><span class="w"> </span><span class="n">Error</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">match</span><span class="w"> </span><span class="n">addr</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="mh">0x100</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="w">                </span><span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="n">bus_request</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="n">reset</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="mh">0x01</span><span class="w"> </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="mh">0x00</span><span class="w"> </span><span class="p">};</span>
<span class="w">            </span><span class="p">},</span>
<span class="w">            </span><span class="n">_</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">warning</span><span class="o">!</span><span class="p">(</span><span class="s">&quot;{}: !!! unhandled read from {:0x}&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">DEV_NAME</span><span class="p">,</span><span class="w"> </span><span class="n">addr</span><span class="p">);</span><span class="w"> </span><span class="p">},</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">        </span><span class="n">info</span><span class="o">!</span><span class="p">(</span><span class="s">&quot;{}: read from register {:x} of {:?}&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">DEV_NAME</span><span class="p">,</span><span class="w"> </span><span class="n">addr</span><span class="p">,</span><span class="w"> </span><span class="n">data</span><span class="p">);</span>
<span class="w">        </span><span class="nb">Ok</span><span class="p">(())</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="k">fn</span><span class="w"> </span><span class="nf">write</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">addr</span><span class="p">:</span><span class="w"> </span><span class="nc">Address</span><span class="p">,</span><span class="w"> </span><span class="n">data</span><span class="p">:</span><span class="w"> </span><span class="kp">&amp;</span><span class="p">[</span><span class="kt">u8</span><span class="p">])</span><span class="w"> </span><span class="p">-&gt;</span><span class="w"> </span><span class="nb">Result</span><span class="o">&lt;</span><span class="p">(),</span><span class="w"> </span><span class="n">Error</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">info</span><span class="o">!</span><span class="p">(</span><span class="s">&quot;{}: write to register {:x} with {:x}&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">DEV_NAME</span><span class="p">,</span><span class="w"> </span><span class="n">addr</span><span class="p">,</span><span class="w"> </span><span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
<span class="w">        </span><span class="k">match</span><span class="w"> </span><span class="n">addr</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="mh">0x000</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="cm">/* ROM vs DRAM mode (not implemented) */</span><span class="w"> </span><span class="p">},</span>
<span class="w">            </span><span class="mh">0x100</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="w">                </span><span class="bp">self</span><span class="p">.</span><span class="n">bus_request</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">            </span><span class="p">},</span>
<span class="w">            </span><span class="mh">0x200</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="w">                </span><span class="bp">self</span><span class="p">.</span><span class="n">reset</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">            </span><span class="p">},</span>
<span class="w">            </span><span class="n">_</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">warning</span><span class="o">!</span><span class="p">(</span><span class="s">&quot;{}: !!! unhandled write {:0x} to {:0x}&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">DEV_NAME</span><span class="p">,</span><span class="w"> </span><span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="w"> </span><span class="n">addr</span><span class="p">);</span><span class="w"> </span><span class="p">},</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">        </span><span class="nb">Ok</span><span class="p">(())</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</code></pre></div>

<p>The last area of the address space to implement is <code>0xc00000</code> to <code>0xc00020</code>, which is mapped to the
VDP.  While there's a lot of internal state to the VDP, it has quite a small interface to the rest
of the system.  Most features of the VDP will be performed during the <code>.step()</code> function, where the
device has access to the <code>System</code> object.  Copying  data from main memory requires access to the
<code>System</code>'s <code>Bus</code> object, so DMA will be implemented in the <code>.step()</code>.</p>
<div class="codehilite"><pre><span></span><code><span class="k">pub</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">Ym7101State</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="n">ctrl_port_buffer</span><span class="p">:</span><span class="w"> </span><span class="nb">Option</span><span class="o">&lt;</span><span class="kt">u16</span><span class="o">&gt;</span><span class="p">,</span><span class="w">  </span><span class="c1">// Used to store the first word of a transfer request</span>
<span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="n">regs</span><span class="p">:</span><span class="w"> </span><span class="p">[</span><span class="mi">22</span><span class="p">;</span><span class="w"> </span><span class="kt">u8</span><span class="p">],</span><span class="w">                 </span><span class="c1">// The internal registers of the VDP</span>
<span class="p">}</span>

<span class="k">pub</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">Ym7101</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="n">state</span><span class="p">:</span><span class="w"> </span><span class="nc">Ym7101State</span><span class="p">,</span>
<span class="p">}</span>

<span class="k">impl</span><span class="w"> </span><span class="n">Ym7101</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="k">fn</span><span class="w"> </span><span class="nf">new</span><span class="p">()</span><span class="w"> </span><span class="p">-&gt;</span><span class="w"> </span><span class="nc">Ym7101</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">Ym7101</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="n">state</span><span class="p">:</span><span class="w"> </span><span class="nc">Ym7101State</span><span class="p">::</span><span class="n">new</span><span class="p">(),</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>

<span class="k">impl</span><span class="w"> </span><span class="n">Steppable</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">Ym7101</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">fn</span><span class="w"> </span><span class="nf">step</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">system</span><span class="p">:</span><span class="w"> </span><span class="kp">&amp;</span><span class="nc">System</span><span class="p">)</span><span class="w"> </span><span class="p">-&gt;</span><span class="w"> </span><span class="nb">Result</span><span class="o">&lt;</span><span class="n">ClockElapsed</span><span class="p">,</span><span class="w"> </span><span class="n">Error</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span>

<span class="w">        </span><span class="nb">Ok</span><span class="p">((</span><span class="mi">1_000_000_000</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="mi">13_423_294</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">4</span><span class="p">)</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>

<span class="k">impl</span><span class="w"> </span><span class="n">Addressable</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">Ym7101</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">fn</span><span class="w"> </span><span class="nf">len</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span><span class="p">-&gt;</span><span class="w"> </span><span class="kt">usize</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="mh">0x20</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="k">fn</span><span class="w"> </span><span class="nf">read</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">addr</span><span class="p">:</span><span class="w"> </span><span class="nc">Address</span><span class="p">,</span><span class="w"> </span><span class="n">data</span><span class="p">:</span><span class="w"> </span><span class="kp">&amp;</span><span class="nc">mut</span><span class="w"> </span><span class="p">[</span><span class="kt">u8</span><span class="p">])</span><span class="w"> </span><span class="p">-&gt;</span><span class="w"> </span><span class="nb">Result</span><span class="o">&lt;</span><span class="p">(),</span><span class="w"> </span><span class="n">Error</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">match</span><span class="w"> </span><span class="n">addr</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="c1">// Read from Data Port</span>
<span class="w">            </span><span class="mh">0x00</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="mh">0x02</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="p">{</span>

<span class="w">            </span><span class="p">},</span>

<span class="w">            </span><span class="c1">// Read from Control Port</span>
<span class="w">            </span><span class="mh">0x04</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="mh">0x06</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="p">{</span>

<span class="w">            </span><span class="p">},</span>

<span class="w">            </span><span class="n">_</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="fm">println!</span><span class="p">(</span><span class="s">&quot;{}: !!! unhandled read from {:x}&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">DEV_NAME</span><span class="p">,</span><span class="w"> </span><span class="n">addr</span><span class="p">);</span><span class="w"> </span><span class="p">},</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">        </span><span class="nb">Ok</span><span class="p">(())</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="k">fn</span><span class="w"> </span><span class="nf">write</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">addr</span><span class="p">:</span><span class="w"> </span><span class="nc">Address</span><span class="p">,</span><span class="w"> </span><span class="n">data</span><span class="p">:</span><span class="w"> </span><span class="kp">&amp;</span><span class="p">[</span><span class="kt">u8</span><span class="p">])</span><span class="w"> </span><span class="p">-&gt;</span><span class="w"> </span><span class="nb">Result</span><span class="o">&lt;</span><span class="p">(),</span><span class="w"> </span><span class="n">Error</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">match</span><span class="w"> </span><span class="n">addr</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="c1">// Write to Data Port</span>
<span class="w">            </span><span class="mh">0x00</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="mh">0x02</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="p">{</span>

<span class="w">            </span><span class="p">},</span>

<span class="w">            </span><span class="c1">// Write to Control Port</span>
<span class="w">            </span><span class="mh">0x04</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="mh">0x06</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="p">{</span>

<span class="w">            </span><span class="p">},</span>

<span class="w">            </span><span class="n">_</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">warning</span><span class="o">!</span><span class="p">(</span><span class="s">&quot;{}: !!! unhandled write to {:x} with {:?}&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">DEV_NAME</span><span class="p">,</span><span class="w"> </span><span class="n">addr</span><span class="p">,</span><span class="w"> </span><span class="n">data</span><span class="p">);</span><span class="w"> </span><span class="p">},</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">        </span><span class="nb">Ok</span><span class="p">(())</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</code></pre></div>

<p>Early in development I called this device Ym7101 after the part number, and it's stuck since then,
so just know that <code>Ym7101</code> is the VDP device.  I'm using a separate <code>Ym7101State</code> object here for
the actual internal data of the VDP because it'll get pretty complicated pretty quickly.  I've since
broken it into 3 objects, one for the DMA and memory management, one for updating the display, and
one to tie it all together and handle the nitty gritty interfacing details, but at this point in the
project, it was just two Rust objects.</p>
<p>The system definition now looks like this:</p>
<div class="codehilite"><pre><span></span><code><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">system</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">System</span><span class="p">::</span><span class="n">new</span><span class="p">();</span>

<span class="kd">let</span><span class="w"> </span><span class="n">rom</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">MemoryBlock</span><span class="p">::</span><span class="n">load</span><span class="p">(</span><span class="s">&quot;binaries/genesis/Sonic2.bin&quot;</span><span class="p">).</span><span class="n">unwrap</span><span class="p">();</span>
<span class="n">system</span><span class="p">.</span><span class="n">add_addressable_device</span><span class="p">(</span><span class="mh">0x00000000</span><span class="p">,</span><span class="w"> </span><span class="n">wrap_transmutable</span><span class="p">(</span><span class="n">rom</span><span class="p">)).</span><span class="n">unwrap</span><span class="p">();</span>

<span class="kd">let</span><span class="w"> </span><span class="n">ram</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">MemoryBlock</span><span class="p">::</span><span class="n">new</span><span class="p">(</span><span class="fm">vec!</span><span class="p">[</span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="mh">0x00010000</span><span class="p">]);</span>
<span class="n">system</span><span class="p">.</span><span class="n">add_addressable_device</span><span class="p">(</span><span class="mh">0x00ff0000</span><span class="p">,</span><span class="w"> </span><span class="n">wrap_transmutable</span><span class="p">(</span><span class="n">ram</span><span class="p">)).</span><span class="n">unwrap</span><span class="p">();</span>

<span class="kd">let</span><span class="w"> </span><span class="n">coproc_mem</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">MemoryBlock</span><span class="p">::</span><span class="n">new</span><span class="p">(</span><span class="fm">vec!</span><span class="p">[</span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="mh">0x00010000</span><span class="p">]);</span>
<span class="n">system</span><span class="p">.</span><span class="n">add_addressable_device</span><span class="p">(</span><span class="mh">0x00a00000</span><span class="p">,</span><span class="w"> </span><span class="n">wrap_transmutable</span><span class="p">(</span><span class="n">coproc_mem</span><span class="p">)).</span><span class="n">unwrap</span><span class="p">();</span>

<span class="kd">let</span><span class="w"> </span><span class="n">controllers</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">genesis</span><span class="p">::</span><span class="n">controllers</span><span class="p">::</span><span class="n">GenesisControllers</span><span class="p">::</span><span class="n">new</span><span class="p">();</span>
<span class="n">system</span><span class="p">.</span><span class="n">add_addressable_device</span><span class="p">(</span><span class="mh">0x00a10000</span><span class="p">,</span><span class="w"> </span><span class="n">wrap_transmutable</span><span class="p">(</span><span class="n">controllers</span><span class="p">)).</span><span class="n">unwrap</span><span class="p">();</span>

<span class="kd">let</span><span class="w"> </span><span class="n">coproc</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">genesis</span><span class="p">::</span><span class="n">coproc_memory</span><span class="p">::</span><span class="n">CoprocessorControl</span><span class="p">::</span><span class="n">new</span><span class="p">();</span>
<span class="n">system</span><span class="p">.</span><span class="n">add_addressable_device</span><span class="p">(</span><span class="mh">0x00a11000</span><span class="p">,</span><span class="w"> </span><span class="n">wrap_transmutable</span><span class="p">(</span><span class="n">coproc</span><span class="p">)).</span><span class="n">unwrap</span><span class="p">();</span>

<span class="kd">let</span><span class="w"> </span><span class="n">vdp</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">genesis</span><span class="p">::</span><span class="n">ym7101</span><span class="p">::</span><span class="n">Ym7101</span><span class="p">::</span><span class="n">new</span><span class="p">();</span>
<span class="n">system</span><span class="p">.</span><span class="n">add_addressable_device</span><span class="p">(</span><span class="mh">0x00c00000</span><span class="p">,</span><span class="w"> </span><span class="n">wrap_transmutable</span><span class="p">(</span><span class="n">vdp</span><span class="p">)).</span><span class="n">unwrap</span><span class="p">();</span>

<span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">cpu</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">M68k</span><span class="p">::</span><span class="n">new</span><span class="p">(</span><span class="n">M68kType</span><span class="p">::</span><span class="n">MC68000</span><span class="p">,</span><span class="w"> </span><span class="mi">7_670_454</span><span class="p">);</span>
<span class="n">system</span><span class="p">.</span><span class="n">add_device</span><span class="p">(</span><span class="s">&quot;cpu&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">wrap_transmutable</span><span class="p">(</span><span class="n">cpu</span><span class="p">)).</span><span class="n">unwrap</span><span class="p">();</span>

<span class="nb">Ok</span><span class="p">(</span><span class="n">system</span><span class="p">)</span>
</code></pre></div>

<p>The ROM still gets stuck in a loop after a certain point, probably because the VDP's interrupts are
not yet implemented, but it gets much farther than before now that the CoprocessorControl object is
responding as the ROM expects.</p>
<p>After putting some print statements into the VDP read and write functions to get a sense of what's
going on, I get the following log messages:</p>
<div class="codehilite"><pre><span></span><code>genesis_controller: read from register 9 the value 0
genesis_controller: read from register b the value 0
genesis_controller: read from register d the value 0
genesis_controller: read from register 1 the value a0
ym7101: control port read 2 bytes from 4 with [0, 0]
ym7101: control port write 2 bytes to 4 with [128, 4]
ym7101: control port write 2 bytes to 4 with [129, 20]
ym7101: control port write 2 bytes to 4 with [130, 48]
ym7101: control port write 2 bytes to 4 with [131, 60]
ym7101: control port write 2 bytes to 4 with [132, 7]
ym7101: control port write 2 bytes to 4 with [133, 108]
ym7101: control port write 2 bytes to 4 with [134, 0]
ym7101: control port write 2 bytes to 4 with [135, 0]
ym7101: control port write 2 bytes to 4 with [136, 0]
ym7101: control port write 2 bytes to 4 with [137, 0]
ym7101: control port write 2 bytes to 4 with [138, 255]
ym7101: control port write 2 bytes to 4 with [139, 0]
ym7101: control port write 2 bytes to 4 with [140, 129]
ym7101: control port write 2 bytes to 4 with [141, 55]
ym7101: control port write 2 bytes to 4 with [142, 0]
ym7101: control port write 2 bytes to 4 with [143, 1]
ym7101: control port write 2 bytes to 4 with [144, 1]
ym7101: control port write 2 bytes to 4 with [145, 0]
ym7101: control port write 2 bytes to 4 with [146, 0]
ym7101: control port write 2 bytes to 4 with [147, 255]
ym7101: control port write 2 bytes to 4 with [148, 255]
ym7101: control port write 2 bytes to 4 with [149, 0]
ym7101: control port write 2 bytes to 4 with [150, 0]
ym7101: control port write 2 bytes to 4 with [151, 128]
ym7101: control port write 2 bytes to 4 with [64, 0]
ym7101: control port write 2 bytes to 6 with [0, 128]
ym7101: data port write 2 bytes to 0 with [0, 0]
coprocessor: write to register 100 with 1
coprocessor: write to register 200 with 1
coprocessor: read from register 100 of [0]
coprocessor: write to register 200 with 0
coprocessor: write to register 100 with 0
coprocessor: write to register 200 with 1
ym7101: write 2 bytes to port 4 with data [129, 4]
ym7101: write 2 bytes to port 6 with data [143, 2]
ym7101: write 2 bytes to port 4 with data [192, 0]
ym7101: write 2 bytes to port 6 with data [0, 0]
ym7101: write 2 bytes to port 0 with data [0, 0]
...
</code></pre></div>

<p>There's more output than this but it eventually stops after a few seconds of running.  The
controllers are accessed first, followed by a bunch of activity trying to talk to the VDP.  The
coprocessor is reset, and then the VDP is accessed again and data is directly written to it.
It continues for another 200 or so lines after what's shown here.  It's mainly the VDP that needs to
do something at this point, in order to get further in the ROM's execution.</p>
<h2 id="memory-and-dma">Memory and DMA</h2>
<p>It's time to get into the details of the VDP, and the natural first place to start is with getting
data into the VDP's various memory areas.  It uses its own memory exclusively to generate the
display output, so data needs to be loaded before anything can be displayed.  As I already mentioned
above, there are three different memory areas that are directly accessible only by the VDP: VRAM,
CRAM, and VSRAM.  CRAM and VSRAM are very small, but VRAM is much larger (64KB, the same size as
main memory), and is used for most of the VDP's functions.</p>
<p>In addition, the CPU and VDP can both directly access main memory, as long as the other is not
accessing it at the same time.  In hardware, this is handled through bus arbitration.  The VDP can
assert the bus request signal, which when active will cause the CPU to temporarily suspend what it's
doing, disconnect from the memory bus, and assert an acknowledge signal to tell the VDP it can use
the bus.  The VDP is then free to access main memory until it de-asserts the bus request signal.</p>
<p align="center">
<img src="images/2022-01/sega-genesis-block-diagram.png" title="Block Diagram showing VDP connections" />
</p>

<p>The green arrows show that the CPU can make a memory request to the VDP or to main RAM, and the VDP
can also make a memory request to main RAM, but only the VDP interface logic can access CRAM, VSRAM,
or VRAM.</p>
<p>The only reason the VDP needs to access main memory is to perform a direct memory access (DMA)
operation, which will copy some contents of main memory into a VDP memory area without using the
CPU.  This direct copying is much faster than if the CPU were to alternate between reading data from
RAM and writing it to the VDP's memory-mapped I/O ports.  It is however possible to also write data
through the CPU, which is used when only a little bit of data needs to be sent.  There is more
overhead required in order to set up a DMA transfer than a CPU transfer, and that might not always
be worth the extra cycles, just to transfer a few words.</p>
<h2 id="talking-to-the-vdp">Talking To The VDP</h2>
<p>To access the VDP from the 68000, the address range from <a href="https://segaretro.org/Sega_Mega_Drive/VDP_general_usage">0xc00000 to
0xc00020</a> is used to read and write to
different VDP "ports" (distinct from the VDP "registers").  Each port is 16-bits wide and most are
mapped to multiple adjacent addresses.  The data port for example, at address <code>0xc00000</code> is also
mirrored at <code>0xc00002</code> so writing a word to either location has the same effect.</p>
<p>Only two ports are really important for most VDP functions: the data port and the control port.  The
control port is used to both set the internal register values of the VDP, as well as to set up
memory operations.  The data port only used to send data to a VDP memory area from the CPU, rather
than through a DMA transfer.</p>
<p>To set a register, the upper most two bits of the 16-bit word written to the control port must be
<code>0b10</code>.  The rest of the upper byte will have the register number (0x00 to 0x17) and the lower byte
will have the new value to load into the register.  The other control words written to the control
port (as part of a transfer setup) are guaranteed to never contain <code>0b10</code> as the upper two bits, so
these bits can be used to distinguish between the two types of requests.</p>
<p>To set up a memory operation, two words must be written to the control port.  The first word
contains almost the entire 16-bit destination address for the operation, minus the two most
significant bits.  The upper two most bits are actually part of the operation mode number, and
exchanging them with the lower two bits of the second word will give the full destination address in
the first word.  The control bits in the second word need to be shifted down two bits, and ORed with
the two bits from the first word to get a 6-bit operation mode which determines the transfer type.
The operation mode specifies if DMA should be used or not, whether to read or write data, and which
of the three memory areas to target.  A DMA request requires more info than provided, which must be
written to the appropriate registers before the transfer request is sent to the control port.</p>
<p>So in the <code>write()</code> method of the <code>Addressable</code> trait from the previous section, I need something
like this:</p>
<div class="codehilite"><pre><span></span><code><span class="n">debug</span><span class="o">!</span><span class="p">(</span><span class="s">&quot;{}: write {} bytes to port {:x} with data {:?}&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">DEV_NAME</span><span class="p">,</span><span class="w"> </span><span class="n">data</span><span class="p">.</span><span class="n">len</span><span class="p">(),</span><span class="w"> </span><span class="n">addr</span><span class="p">,</span><span class="w"> </span><span class="n">data</span><span class="p">);</span>

<span class="kd">let</span><span class="w"> </span><span class="n">value</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">read_beu16</span><span class="p">(</span><span class="n">data</span><span class="p">);</span>
<span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">value</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="mh">0xC000</span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mh">0x8000</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="bp">self</span><span class="p">.</span><span class="n">regs</span><span class="p">[((</span><span class="n">data</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="mh">0x1F00</span><span class="p">)</span><span class="w"> </span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="mi">8</span><span class="p">)</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="kt">usize</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">data</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="mh">0x00FF</span><span class="p">)</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="kt">u8</span><span class="p">;</span>
<span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">match</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="n">state</span><span class="p">.</span><span class="n">ctrl_port_buffer</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="nb">None</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="bp">self</span><span class="p">.</span><span class="n">state</span><span class="p">.</span><span class="n">ctrl_port_buffer</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">Some</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
<span class="w">        </span><span class="p">},</span>
<span class="w">        </span><span class="nb">Some</span><span class="p">(</span><span class="n">first</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="kd">let</span><span class="w"> </span><span class="n">second</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">value</span><span class="p">;</span>
<span class="w">            </span><span class="bp">self</span><span class="p">.</span><span class="n">state</span><span class="p">.</span><span class="n">ctrl_port_buffer</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">None</span><span class="p">;</span>

<span class="w">            </span><span class="bp">self</span><span class="p">.</span><span class="n">transfer_type</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">((((</span><span class="n">first</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="mh">0xC000</span><span class="p">)</span><span class="w"> </span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="mi">14</span><span class="p">)</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="p">((</span><span class="n">second</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="mh">0x00F0</span><span class="p">)</span><span class="w"> </span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="mi">2</span><span class="p">)))</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="kt">u8</span><span class="p">;</span>
<span class="w">            </span><span class="bp">self</span><span class="p">.</span><span class="n">transfer_addr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">((</span><span class="n">first</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="mh">0x3FFF</span><span class="p">)</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="p">((</span><span class="n">second</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="mh">0x0003</span><span class="p">)</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="mi">14</span><span class="p">))</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="kt">u32</span><span class="p">;</span>
<span class="w">            </span><span class="n">debug</span><span class="o">!</span><span class="p">(</span><span class="s">&quot;{}: transfer requested of type {:x} to address {:x}&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">DEV_NAME</span><span class="p">,</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="n">transfer_type</span><span class="p">,</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="n">transfer_addr</span><span class="p">);</span>
<span class="w">        </span><span class="p">},</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</code></pre></div>

<p>Hmmm... when I run it I get the following log message, but not the log message that a transfer was
requested.</p>
<div class="codehilite"><pre><span></span><code>ym7101: write 4 bytes to port 4 with data [0x40, 0x00, 0x00, 0x80]
</code></pre></div>

<p>The CPU is writing 4 bytes at once.  Oh right!  Of course it is.  The CPU implementation is using
the helper functions to read and write 4 bytes at once when an instruction accesses a long word.
The ROM is using a single <code>movel</code> instruction to write both words of the transfer setup rather than
using two instructions.  This is also why the VDP's data and control ports are mirrored at the
adjacent addresses, because in hardware, the CPU would write a word to the first address, and then
write a second word to that address plus two.</p>
<p>Digging around in the logs shows that the same thing is actually being done with register
assignments as well.  Two register assignments can be put into a single instruction like
<code>movel #0x80048114, (%a4)</code>, where <code>%a4</code> contains the address of the control port <code>0xC00004</code>.
That would set both VDP register 0 to 0x04, and VDP register 1 to 0x14.</p>
<p>For now, I'll just modify the <code>.write()</code> function to allow long word accesses:</p>
<div class="codehilite"><pre><span></span><code><span class="kd">let</span><span class="w"> </span><span class="n">value</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">read_beu16</span><span class="p">(</span><span class="n">data</span><span class="p">);</span>
<span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">value</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="mh">0xC000</span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mh">0x8000</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="bp">self</span><span class="p">.</span><span class="n">state</span><span class="p">.</span><span class="n">set_register</span><span class="p">(</span><span class="n">value</span><span class="p">);</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="n">data</span><span class="p">.</span><span class="n">len</span><span class="p">()</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">4</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">value</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">read_beu16</span><span class="p">(</span><span class="o">&amp;</span><span class="n">data</span><span class="p">[</span><span class="mi">2</span><span class="o">..</span><span class="p">]);</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">value</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="mh">0xC000</span><span class="p">)</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="mh">0x8000</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="k">return</span><span class="w"> </span><span class="nb">Err</span><span class="p">(</span><span class="n">Error</span><span class="p">::</span><span class="n">new</span><span class="p">(</span><span class="o">&amp;</span><span class="fm">format!</span><span class="p">(</span><span class="s">&quot;{}: unexpected second byte {:x}&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">DEV_NAME</span><span class="p">,</span><span class="w"> </span><span class="n">value</span><span class="p">)));</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">        </span><span class="bp">self</span><span class="p">.</span><span class="n">state</span><span class="p">.</span><span class="n">set_register</span><span class="p">(</span><span class="n">value</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">match</span><span class="w"> </span><span class="p">(</span><span class="n">data</span><span class="p">.</span><span class="n">len</span><span class="p">(),</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="n">state</span><span class="p">.</span><span class="n">ctrl_port_buffer</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="nb">None</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="n">state</span><span class="p">.</span><span class="n">ctrl_port_buffer</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">Some</span><span class="p">(</span><span class="n">value</span><span class="p">)</span><span class="w"> </span><span class="p">},</span>
<span class="w">        </span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="nb">Some</span><span class="p">(</span><span class="n">upper</span><span class="p">))</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="n">state</span><span class="p">.</span><span class="n">setup_transfer</span><span class="p">(</span><span class="n">upper</span><span class="p">,</span><span class="w"> </span><span class="n">read_beu16</span><span class="p">(</span><span class="n">data</span><span class="p">)),</span>
<span class="w">        </span><span class="p">(</span><span class="mi">4</span><span class="p">,</span><span class="w"> </span><span class="nb">None</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="n">state</span><span class="p">.</span><span class="n">setup_transfer</span><span class="p">(</span><span class="n">value</span><span class="p">,</span><span class="w"> </span><span class="n">read_beu16</span><span class="p">(</span><span class="o">&amp;</span><span class="n">data</span><span class="p">[</span><span class="mi">2</span><span class="o">..</span><span class="p">])),</span>
<span class="w">        </span><span class="n">_</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">error</span><span class="o">!</span><span class="p">(</span><span class="s">&quot;{}: !!! error when writing to control port with {} bytes of {:?}&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">DEV_NAME</span><span class="p">,</span><span class="w"> </span><span class="n">data</span><span class="p">.</span><span class="n">len</span><span class="p">(),</span><span class="w"> </span><span class="n">data</span><span class="p">);</span><span class="w"> </span><span class="p">},</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</code></pre></div>

<p>It's a bit clumsy but it works for testing.  I eventually added a mechanism called <code>BusPort</code> which
simulates the CPU's connection to the <code>Bus</code> object in <code>System</code>.  The <code>BusPort</code> is created when the
CPU object is created, and it's stored in the CPU object.  The CPU will then use it for all read and
write operations to more accurately simulate the bus.  Any read or write call on <code>BusPort</code> will be
broken into multiple operations if necessary in order to fit the given data bus size, and the
address will be masked to the given address bus size.  This will also fix the issue with 24-bit
addressing on the 68000.  At the same time, it's possible to configure a CPU as a 68030 with a
32-bit address and data bus, which I intend to use for future Computie hardware revisions, and
possibly other systems.</p>
<h2 id="implementing-the-memory-ops">Implementing The Memory Ops</h2>
<p>Now that the <code>Addressable</code> implementation can receive the control port transfer setup, it's time to
actually implement the transfer operations, both through the data port and through DMA.  For a
manual transfer, once configured, data can either be read from or written to the data port.  After
each memory operation, the destination address will be increment by the value stored in the auto
increment register of the VDP (register <code>0x0f</code>).  It doesn't matter what size the operation was; the
address will always be incremented by that value, so it must be set correctly.</p>
<p>A DMA transfer, on the other hand, takes place as soon as the second transfer configuration word is
written to the control port, assuming the DMA enable bit is set in the Mode2 register (<code>0x01</code>).  In
hardware, the VDP would assert the bus request signal to tell the CPU to disconnect from the memory
bus while the VDP directly accesses the main RAM to copy data into its VRAM.  Once the operation is
complete, the VDP would de-assert the bus request signal and the CPU would continue where it left
off.  I cheated a bit by simply performing the complete operation in one call to the <code>.step()</code>
function, rather than simulating the time it would take.  It's worked fine so far.</p>
<p>In order to perform a DMA transfer, there are two additional values that are needed.  The source
address in RAM where the data to copy is located, and the amount of data to be copied.  These values
are stored across 5 different 8-bit registers in the VDP, which must be set before configuring the
transfer through the control port.  The count value is split across registers <code>0x13</code> and <code>0x14</code>,
each containing half of the 16-bit count.  The source address is split across registers <code>0x15</code> to
<code>0x17</code> where the address is shifted to the right one bit, since the address must start on an even
byte address (ie. bit 0 must always be zero, so it's not even stored in the register).  The upper
two bits of register <code>0x17</code>, which is the high part of the address, specifies whether the operation
is a transfer, copy, or fill.  See <a href="https://wiki.megadrive.org/index.php?title=VDP_Registers#0x17_-_DMA_source_address_high">VDP
Registers</a>
for details.</p>
<p>To make the code easier to understand, I made a simple enum called <code>DmaType</code> to hold the type of
operation, or <code>DmaType::None</code> if there is no operation pending.  The addresses and counts are
assembled from the register values when the transfer is set up through the control port.</p>
<p>The following code was then added to the VDP's <code>.step()</code> function.  The transfer operation type is
selected by the <code>self.transfer_run</code> value.  Each type has its own loop which iterates until the
remaining count is 0.  The destination address is incremented by the value of the auto increment
register (<code>0x0f</code>) after each iteration, just like a manual transfer.  The <code>DmaType::Memory</code>
operation is a bit more involved since it must use the system bus to read data.  In order to reuse
the same loop for each of the three target memory areas, the <code>.get_transfer_target_mut()</code> function
returns a slice of the appropriate memory area.</p>
<div class="codehilite"><pre><span></span><code><span class="k">match</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="n">transfer_run</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">DmaType</span><span class="p">::</span><span class="nb">None</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="cm">/* Do Nothing */</span><span class="w"> </span><span class="p">},</span>

<span class="w">    </span><span class="n">DmaType</span><span class="p">::</span><span class="n">Memory</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">info</span><span class="o">!</span><span class="p">(</span><span class="s">&quot;{}: starting dma transfer {:x} from Mem:{:x} to {:?}:{:x} ({} bytes)&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">DEV_NAME</span><span class="p">,</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="n">transfer_type</span><span class="p">,</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="n">transfer_src_addr</span><span class="p">,</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="n">transfer_target</span><span class="p">,</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="n">transfer_dest_addr</span><span class="p">,</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="n">transfer_remain</span><span class="p">);</span>
<span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">bus</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">system</span><span class="p">.</span><span class="n">get_bus</span><span class="p">();</span>

<span class="w">        </span><span class="k">while</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="n">transfer_remain</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">data</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="mi">2</span><span class="p">];</span>
<span class="w">            </span><span class="n">bus</span><span class="p">.</span><span class="n">read</span><span class="p">(</span><span class="bp">self</span><span class="p">.</span><span class="n">transfer_src_addr</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="n">Address</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="n">data</span><span class="p">)</span><span class="o">?</span><span class="p">;</span>

<span class="w">            </span><span class="kd">let</span><span class="w"> </span><span class="n">addr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="n">transfer_dest_addr</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="kt">usize</span><span class="p">;</span>
<span class="w">            </span><span class="kd">let</span><span class="w"> </span><span class="n">target</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="n">get_transfer_target_mut</span><span class="p">();</span>
<span class="w">            </span><span class="n">target</span><span class="p">[</span><span class="n">addr</span><span class="w"> </span><span class="o">%</span><span class="w"> </span><span class="n">target</span><span class="p">.</span><span class="n">len</span><span class="p">()]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
<span class="w">            </span><span class="n">target</span><span class="p">[(</span><span class="n">addr</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="o">%</span><span class="w"> </span><span class="n">target</span><span class="p">.</span><span class="n">len</span><span class="p">()]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">data</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>

<span class="w">            </span><span class="bp">self</span><span class="p">.</span><span class="n">transfer_dest_addr</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="n">transfer_auto_inc</span><span class="p">;</span>
<span class="w">            </span><span class="bp">self</span><span class="p">.</span><span class="n">transfer_src_addr</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span>
<span class="w">            </span><span class="bp">self</span><span class="p">.</span><span class="n">transfer_remain</span><span class="w"> </span><span class="o">-=</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">},</span>

<span class="w">    </span><span class="n">DmaType</span><span class="p">::</span><span class="nb">Copy</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">info</span><span class="o">!</span><span class="p">(</span><span class="s">&quot;{}: starting dma copy from VRAM:{:x} to VRAM:{:x} ({} bytes)&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">DEV_NAME</span><span class="p">,</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="n">transfer_src_addr</span><span class="p">,</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="n">transfer_dest_addr</span><span class="p">,</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="n">transfer_remain</span><span class="p">);</span>
<span class="w">        </span><span class="k">while</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="n">transfer_remain</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="bp">self</span><span class="p">.</span><span class="n">vram</span><span class="p">[</span><span class="bp">self</span><span class="p">.</span><span class="n">transfer_dest_addr</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="kt">usize</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="n">vram</span><span class="p">[</span><span class="bp">self</span><span class="p">.</span><span class="n">transfer_src_addr</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="kt">usize</span><span class="p">];</span>
<span class="w">            </span><span class="bp">self</span><span class="p">.</span><span class="n">transfer_dest_addr</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="n">transfer_auto_inc</span><span class="p">;</span>
<span class="w">            </span><span class="bp">self</span><span class="p">.</span><span class="n">transfer_src_addr</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="w">            </span><span class="bp">self</span><span class="p">.</span><span class="n">transfer_remain</span><span class="w"> </span><span class="o">-=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">},</span>

<span class="w">    </span><span class="n">DmaType</span><span class="p">::</span><span class="n">Fill</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">info</span><span class="o">!</span><span class="p">(</span><span class="s">&quot;{}: starting dma fill to VRAM:{:x} ({} bytes) with {:x}&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">DEV_NAME</span><span class="p">,</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="n">transfer_dest_addr</span><span class="p">,</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="n">transfer_remain</span><span class="p">,</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="n">transfer_fill_word</span><span class="p">);</span>
<span class="w">        </span><span class="k">while</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="n">transfer_remain</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="bp">self</span><span class="p">.</span><span class="n">vram</span><span class="p">[</span><span class="bp">self</span><span class="p">.</span><span class="n">transfer_dest_addr</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="kt">usize</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="n">transfer_fill_word</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="kt">u8</span><span class="p">;</span>
<span class="w">            </span><span class="bp">self</span><span class="p">.</span><span class="n">transfer_dest_addr</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="n">transfer_auto_inc</span><span class="p">;</span>
<span class="w">            </span><span class="bp">self</span><span class="p">.</span><span class="n">transfer_remain</span><span class="w"> </span><span class="o">-=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">},</span>
<span class="p">}</span>

<span class="c1">// Reset the mode after a transfer has completed</span>
<span class="bp">self</span><span class="p">.</span><span class="n">set_dma_mode</span><span class="p">(</span><span class="n">DmaType</span><span class="p">::</span><span class="nb">None</span><span class="p">);</span>
</code></pre></div>

<p>Note: this code includes a bug that I'll fix in Part III.  Bonus points if you can spot it</p>
<p>The helper function <code>.set_dma_mode()</code> is used to also control the DMA busy flag in the VDP's status
word, which is returned when reading from VDP's control port (instead of writing).  It's probably
not that important since the CPU technically shouldn't be running when a DMA is in progress, but I
threw it in for completeness.</p>
<div class="codehilite"><pre><span></span><code><span class="k">pub</span><span class="w"> </span><span class="k">fn</span><span class="w"> </span><span class="nf">set_dma_mode</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">mode</span><span class="p">:</span><span class="w"> </span><span class="nc">DmaType</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">match</span><span class="w"> </span><span class="n">mode</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">DmaType</span><span class="p">::</span><span class="nb">None</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="bp">self</span><span class="p">.</span><span class="n">status</span><span class="w"> </span><span class="o">&amp;=</span><span class="w"> </span><span class="o">!</span><span class="n">STATUS_DMA_BUSY</span><span class="p">;</span>
<span class="w">            </span><span class="bp">self</span><span class="p">.</span><span class="n">transfer_run</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">DmaType</span><span class="p">::</span><span class="nb">None</span><span class="p">;</span>
<span class="w">        </span><span class="p">},</span>
<span class="w">        </span><span class="n">_</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="bp">self</span><span class="p">.</span><span class="n">status</span><span class="w"> </span><span class="o">|=</span><span class="w"> </span><span class="n">STATUS_DMA_BUSY</span><span class="p">;</span>
<span class="w">            </span><span class="bp">self</span><span class="p">.</span><span class="n">transfer_run</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">mode</span><span class="p">;</span>
<span class="w">        </span><span class="p">},</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</code></pre></div>

<p>Phew!  That was a lot of boring bits, but it's done now.  Testing is another matter, but without a
reference to compare it to, it's hard to find problems without the display output.  It will get more
interesting soon.</p>
<h2 id="next-time">Next Time</h2>
<p>By this point I had only been working on the Genesis support for about a week, while also working on
other parts of the emulator.  The time spent on the Genesis was mostly reading up on how it worked.
I was flying through everything, making great progress, and having a lot of fun at the same time.</p>
<p>The CPU to VDP interface was pretty much implemented and I could get data into the VDP registers and
memory areas.  The next step was to use that data to generate an image and send it to some kind of
window on the local machine.  That's an entire post's worth of effort, so... I'll make another post!
Click <a href="https://jabberwocky.ca/posts/2022-01-emulating_the_sega_genesis_part2.html">Part II</a> to continue</p>

    </div>
    <div id="footer">
        <hr>
        Made with <a href="../generate.py">Python</a>
        <div class="email">trans@jabberwocky.ca</div>
    </div>
</div>
</body>
</html>

