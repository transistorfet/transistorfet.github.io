<!DOCTYPE html>
<html>
<head>
    <title>Molten</title>

    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />

    <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Recursive" type="text/css" charset="utf-8" />
    <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=IBM+Plex+Mono" type="text/css" charset="utf-8" />
    <link rel="stylesheet" href="../../assets/normalize.css" type="text/css" charset="utf-8" />
    <link rel="stylesheet" href="../../assets/layout.css" type="text/css" charset="utf-8" />
    <link rel="stylesheet" href="../../assets/code.css" type="text/css" charset="utf-8" />
</head>
<body>
<div id="main">

    <div id="menu-toggle">&#x2630;</div>
    <input class="toggle-trigger" type="checkbox" checked />
    <div id="sidebar" class="toggle">
        <a href="../.."><h2>Projects</h2></a>
        <hr>

<a href="#download">Get the Source</a><hr>
<a href="../../projects/computie">Computie 68k</a><br>
<a href="../../projects/molten">Molten</a><br>
<a href="../../projects/nerve">Nerve Control Network</a><br>
<a href="../../projects/rgbnode">RGB Node</a><br>
<a href="../../projects/rgbnode-rs">RGB Node with Rust</a><br>
<a href="../../projects/webmush">WebMUSH</a><br>
<a href="../../projects/conlog">Conlog</a><br>
<a href="../../projects/fallingrust">Falling Rust</a><br>
<a href="../../projects/abugslife">A Bug's Life</a><br>
<a href="../../projects/acamlslife">A Caml's Life</a><br>
<a href="../../projects/synthetik">Synthetik Synth</a><br>
<a href="../../projects/meteorman">Meteor Games</a><br>
<a href="../../projects/logarithm">Logarithm IRC Bot</a><br>
<a href="../../projects/sdm">Super Duper Moo</a><br>
<a href="../../projects/sdrl">SDRL Interpreter</a><br>
<a href="../../projects/stutter">Stutter IRC Client</a><br>
<hr>
<h3>Posts</h3>
<ul><li><a href="../../posts/2021-09-bootstrapping_with_arduino.html">Bootstrapping a Homebuilt Computer Using An Arduino</a></li>
<li><a href="../../posts/molten_overview.html">An Overview Of Molten Internals</a></li>
</ul>
        <hr>
        <a href="https://github.com/transistorfet"><img width="32" src="../../assets/github.png"></a>
        <a href="https://twitter.com/transistorfet"><img width="32" src="../../assets/twitter.svg"></a>
        <a href="https://linkedin.com/in/sarimcfarland"><img width="32" src="../../assets/linkedin.png"></a>
    </div>
    <div id="content">

<h1>Molten</h1>
<h6><em>Started November 06, 2017</em></h6>
<p>Molten is a programming language which borrows from the ML family of languages,
as well as from Rust and Python.  The compiler is written in Rust and uses LLVM
to generate IR which can be compiled to machine code.</p>
<p>I originally started this project in order to learn Rust.  It is intended to be
a high level language with a full object system that facilitates both functional
and object-oriented programming.  Some syntax elements have been changed from
typical ML languages to follow conventions found in more common languages, such
as C++, Rust, and Python (eg. parenthesis-delimited blocks, conventional class
definitions, generics/type parameters with angle brackets, etc).  For more info
on the internals, see <a href="https://transistorfet.github.io/posts/molten_overview.html">An Overview Of Molten
Internals</a></p>
<h2>Installing</h2>
<p>You will need <code>rustc</code> and <code>cargo</code> installed.  It's recommended that you use
<code>rustup</code> to install these.  I've most recently tested it with rustc version
1.52.  You will also need LLVM 11 installed, as well as libgc
(Boehm-Demers-Weiser's Garbage Collector), and clang for linking, although clang
can be replace with gcc by editing the <code>molten</code> python script.</p>
<p>On Debian/Ubuntu, run:
<code>sudo apt-get install llvm-11 llvm-11-runtime llvm-11-dev clang libgc-dev</code></p>
<p>On macOS, run:
<code>brew install llvm@11</code></p>
<p>You may need to add /usr/local/opt/llvm@11/bin to your path, and you will probably
need to install libgc separately</p>
<h2>Running</h2>
<p>The <code>molten</code> script helps with compiling and linking IR files.  To run an example:</p>
<div class="codehilite"><pre><span></span><code>./molten run examples/fac.mol
</code></pre></div>

<p>This will run cargo to build the compiler if needed, then compile the fac.mol
file, as well as all of its dependencies (in this case, the libcore.mol
library), link them together using clang, along with libgc, and then run the
binary.  It can also compile to LLVM IR, and run LLVM bitcode by using the <code>-S</code>
flag.  The resulting .bc file can be run using <code>lli-11</code>.</p>
<h2>Example</h2>
<div class="codehilite"><pre><span></span><code>fn fac(x) {
    if x &lt; 1 then
        1
    else
        x * fac(x - 1)
}

println(str(fac(10)))
</code></pre></div>

<h3>Types</h3>
<div class="codehilite"><pre><span></span><code>()                  // unit type
Nil
Bool
Byte
Char                // UCS-4 character
Int
Real
String
(Int, Int) -&gt; Int   // function type
&#39;a                  // universal type variable
Array&lt;Int&gt;          // array of integers
(Int, Real)         // tuple type
{ a: Int, b: Real } // record type
</code></pre></div>

<h3>Declarations</h3>
<div class="codehilite"><pre><span></span><code>let foo = 0
let bar: String = &quot;Hey&quot;
</code></pre></div>

<h3>Functions</h3>
<div class="codehilite"><pre><span></span><code>fn foo(x, y) =&gt; x + y           // named inline function

fn foo(x, y) { x + y }          // named block function

let foo = fn x, y =&gt; x + y      // anonymous function

fn foo(x: Int, y) -&gt; Int { x + y }  // with optional type annotations
</code></pre></div>

<h3>Invoking Functions</h3>
<p>Unlike in ML, the brackets of a function call are not elidable.  This is a
design decision to improve readability of the code and to make the parser
simpler and more predictable.</p>
<div class="codehilite"><pre><span></span><code>foo(1, 2)
</code></pre></div>

<h3>Blocks</h3>
<p>A block is a collection of expressions which return the result of the last
expression in the block.  They can be used in place of a single expression.
They do not create their own local scope, at least at the moment, so variables
defined inside blocks will appear in the parent scope (usually the function the
block is in).  Each expression in the block must end in a newline or semi-colon
character (or be the last expression in the block).  This applies to the top
level.</p>
<div class="codehilite"><pre><span></span><code>let is_zero = if self.x &lt;= 0 then {
    self.x = 0
    true
} else {
    false
}
</code></pre></div>

<h3>Math</h3>
<p>Infix operators are evaluated using order of operations.  Both sides of an infix
operation must be on the same line, or a <code>\</code> character can be used to
continue the line.</p>
<div class="codehilite"><pre><span></span><code>5 + 12 * 2      // equals 29

42 * 4 \
   % 5          // equals 3
</code></pre></div>

<h3>And / Or</h3>
<p>The keyword operators <code>and</code> and <code>or</code> have side-effects and will not execute the
second expression if the result can be determined from the first expression.
The expressions must have the same type, and the returned value is the first
expression that returns a non-zero value.</p>
<div class="codehilite"><pre><span></span><code>let is_cat = true
let result = is_cat and println(&quot;It&#39;s a cat&quot;) == ()
</code></pre></div>

<p>Since is_cat is Bool, both sides of the <code>and</code> must be Bool.  Since the
<code>println()</code> function returns Unit, we compare it with itself which will always
be true.  The <code>println()</code> will only execute if <code>is_cat</code> is true, and <code>result</code>
will be true if <code>is_cat</code> is true, or false if <code>is_cat</code> is false.</p>
<h3>Tuples</h3>
<div class="codehilite"><pre><span></span><code>let tup = (1, &quot;String&quot;, 4.5)
println(tup.1)                  // prints &quot;String&quot;
</code></pre></div>

<h3>Records</h3>
<p>Records are like tuples but with named fields.  Record literals use the equals
sign ("=") to assign a value to a field.  Specifying a record type uses a colon
(":") to separate the field name from the type.</p>
<div class="codehilite"><pre><span></span><code>let rec = { i = 1, s = &quot;String&quot;, r = 4.5 }
println(rec.s)                  // prints &quot;String&quot;

let rec: { i: Int, s: String, r: Real }
</code></pre></div>

<p>Records can be updated, which will copy all fields of the record into a new
record, but with some of the fields modified.</p>
<div class="codehilite"><pre><span></span><code>let rec = { i = 1, s = &quot;String&quot;, r = 4.5 }

let newrec = { rec with s = &quot;Updated&quot; }
println(&quot;New Value: &quot; + newrec.s)       // prints &quot;Updated&quot;
println(&quot;Old Value: &quot; + rec.s)          // prints &quot;String&quot;
</code></pre></div>

<h3>Arrays</h3>
<div class="codehilite"><pre><span></span><code>let array1 = [ 1, 3, 6 ]
for x in array1
    println(str(x))

let array2 = new Array&lt;String&gt;();
array2.insert(0, &quot;Hello&quot;)
println(array2[0])
</code></pre></div>

<p>The Array type is defined in libcore, which must be imported if arrays are used.</p>
<h3>Flow Control</h3>
<p>The return value of an if expression is the result of evaluating either the
<code>then</code> clause or <code>else</code> clause.  The types of both clauses must match.  The
<code>else</code> clause can be left out as long as the true clause evaluates to Nil.</p>
<div class="codehilite"><pre><span></span><code>if x == 5 then
    &quot;It&#39;s five&quot;
else
    &quot;It&#39;s not five&quot;
</code></pre></div>

<p>A match expression allows pattern matching, which can unpack refs, tuples,
records, and enums.  It can bind values to named variables in the pattern and
creates a new scope for each arm of the match expression.</p>
<div class="codehilite"><pre><span></span><code>match x with
| 1 =&gt; &quot;It&#39;s one&quot;
| 5 =&gt; &quot;It&#39;s five&quot;
| num =&gt; &quot;It&#39;s not one or five, it&#39;s &quot; + str(num)
</code></pre></div>

<p>Values can be unpacked with match as well, including records, tuples, refs, and
enum variants.  A underscore <code>_</code> will match any value, and an identifier (eg.
<code>value</code>) will match anything and bind that value to the name in the process, so
that it can be referenced inside the match arm.  Here's an example using a
record:</p>
<div class="codehilite"><pre><span></span><code>match { num = 10, name = &quot;Ten&quot; } with
| { num = 10, name = value } =&gt; println(value)
| { num = _, name = value } =&gt; println(&quot;Something else named &quot; + value)
</code></pre></div>

<h3>Loops</h3>
<div class="codehilite"><pre><span></span><code>while true
    println(&quot;looping&quot;)

for i in iter([ 1, 2, 3 ])
    println(&quot;counting &quot; + i)
</code></pre></div>

<p>For loops take an instance of <code>Iterator&lt;'item&gt;</code> and calls the <code>.next()</code> method
on it, running the body for each <code>Option::Some('item)</code> returned.  The <code>iter</code>
function is defined for different types to convert them into an appropriate
iterator.  In the case of arrays, it will return the result of <code>new
ArrayInterator&lt;'item&gt;(input_array)</code></p>
<h3>Refs</h3>
<p>A ref is an indirect reference to some data.  It can be passed around as a
value, and dereferenced to get or set the data inside of it.  The internal value
of a reference is always mutable</p>
<div class="codehilite"><pre><span></span><code>let r = ref 42
println(str(*r))                // prints 42
*r = 65
println(str(*r))                // prints 65

fn foo(x: ref Int) { }          // ref types look similar to ref constructors

let r = ref { a = 42, b = &quot;The Answer&quot; }
println(*r.b)                   // prints &quot;The Answer&quot;
</code></pre></div>

<h3>Classes</h3>
<div class="codehilite"><pre><span></span><code>class Foo {
    // A field with type String
    val mut name: String

    fn new(self, name) {
        self.name = name
    }

    fn get(self) =&gt; self.name

    fn static(x) =&gt; x * 2
}

class Bar extends Foo {
    fn get(self, title) =&gt; self.name + &quot; &quot; + title
}

let bar = new Bar(&quot;Mischief&quot;)
bar.get(&quot;The Cat&quot;)              // returns &quot;Mischief The Cat&quot;
Foo::static(5)
</code></pre></div>

<p>All methods are both closures, and virtual methods, so they can access variables
in their parents' scopes and also be overridden by a child class's
implementation of the same method, accessible with a reference to the parent
class type.</p>
<p>Fields can have an optional type, but not an initializer.  If a class has at
least one field, it must have at least one "new" constructor, which must assign
to each field an initial value.  The type can be inferred from this assignment
if the optional type is not supplied.  If a field is declared as mutable, it can
be reassigned to, but if the <code>mut</code> keyword is absent, the field can only be
assigned to within the constructor, and will be immutable after the constructor
has returned.  Every constructor must also call the <code>Super::new</code> method of its
parent class, if it has a parent that has a constructor.</p>
<h3>Enums (Tagged Unions)</h3>
<p>An enum can either have no arguments, or a tuple of arguments.  Constructing an
enum variant requires using the Resolve (::) notation.  Pattern matching is
currently the only way to get values out of a variant.  Unlike with classes,
which allocate memory for a new instance, enums are immediate data types like
tuples and records.  In order to store it in a memory location, a <code>ref</code> must be
used.  A ref is required in order to make a recursive enum.</p>
<div class="codehilite"><pre><span></span><code>enum Value =
| None
| Integer(Int)
| String(String)
| Pair(String, String)
| Reference(ref Value)          // A recursive reference

let val = Value::String(&quot;Hey&quot;)

match val with
| Value::String(s) =&gt; println(s)
| _ =&gt; ()
</code></pre></div>

<p>Methods can be added to enums using a <code>methods</code> body.  Currently it can only be
used with enums.</p>
<div class="codehilite"><pre><span></span><code>methods Value {
    fn is_some(val: Value) {
        match val with
        | Value::None =&gt; false
        | _ =&gt; true
    }
}

val.is_some()
</code></pre></div>

<h3>Traits and Trait Objects</h3>
<p>A trait can be defined with method declarations in the body, with the predefined
type alias "Self" used to refer to the current trait object</p>
<div class="codehilite"><pre><span></span><code>trait Add {
    decl add(Self, Self) -&gt; Self
}
</code></pre></div>

<p>A trait can then be implemented for a given type.  An impl block can only have
function definitions that match the trait declarations.  Inside the impl block
the "Self" type alias will refer to the implementation type.  Trait objects that
are passed to arguments with type "Self" will automatically be unpacked into
their impl type, and if the return type has type "Self", the result will
automatically be packed back into a trait object.</p>
<div class="codehilite"><pre><span></span><code>impl Add for Int {
    fn add(x: Self, y: Self) -&gt; Self {
        x + y
    }
}

impl Add for Real {
    fn add(x: Self, y: Self) -&gt; Self {
        x + y
    }
}
</code></pre></div>

<p>Traits are not an object type, but instead are specified as a constraint on a
universal variable using a <code>where</code> clause.  If the actual type given does not
implement the constrained trait, then an type error will be raised.  Currently
trait objects can only be created by passing them into a function that takes a
universal variable with a constraint.  At the moment, only one trait can be
specified as a constraint but this will be changed in future.</p>
<div class="codehilite"><pre><span></span><code>fn do_some_adding(x: &#39;a) -&gt; &#39;a where a: Add {
    x.add(x)
}

println(str(do_some_adding(400)))
println(str(do_some_adding(1.5)))
</code></pre></div>

<p>The above example will output:</p>
<div class="codehilite"><pre><span></span><code>800
3.000000
</code></pre></div>

<h3>Exceptions</h3>
<p>All exceptions must be an instance of the <code>Exception</code> class defined in libcore.</p>
<div class="codehilite"><pre><span></span><code>try open(&quot;file.txt&quot;)
with e =&gt; println(&quot;Exception Occurred: &quot; + e.msg)

try {
    //...
    raise new Exception(&quot;Problem&quot;)
} with
    e =&gt; println(e.msg)
</code></pre></div>

<h3>Annotations</h3>
<p>A value can be type annotated using a colon followed by the type.</p>
<div class="codehilite"><pre><span></span><code>5 : Int
str(i : Int)
(func() : String)
</code></pre></div>

<h3>Import</h3>
<div class="codehilite"><pre><span></span><code>import libcore
</code></pre></div>

<h3>External Functions</h3>
<p>A function can be declared without being implemented, and functions can also be
defined with an ABI specifier so that they are accessible to other languages.
Only C support is currently implemented. A C function cannot be a closure.</p>
<div class="codehilite"><pre><span></span><code>decl foo(Int) -&gt; Int         // external molten function
decl bar(Int) -&gt; Int / C     // external C function

fn baz(i: Int) / C {
    // molten function that can be called from C
}
</code></pre></div>

<h3>Linking to C</h3>
<p>An example of writing a C file, and linking it to a molten program is shown in
<code>lib/libccore.c</code>.  When imported into a molten file and compiled with the
<code>molten</code> script, the library will be compiling using clang and the
<code>libccore.cdec</code> (manually maintained) will be copied to <code>libccore.dec</code>.  The
importing molten program will be able to use declarations from libccore.cdec.
Some declarations that can be used in C are in <code>include/molten.h</code>, such as
accessing the garbage collected allocator.</p>
<h2>Previously Uncompleted</h2>
<ul>
<li>
<p>Dynamic Dispatch/vtables works now!</p>
</li>
<li>
<p>Closures have been implemented! Most functions and methods are now
  closures, although there is a new ABI type (MF) which is a
  non-closure function that can still be overloaded and can still
  throw exceptions (when they're implemented). It's mostly used by
  builtin functions</p>
</li>
<li>
<p>Class field initializers are working!  It now adds a new closure to
  each class called <strong>init</strong> which is called during "new" to initialize
  the class members</p>
</li>
<li>
<p>Exceptions have finally been added using the setjmp/longjmp functions</p>
</li>
<li>
<p>Enums have been added but with a lot of limitations.  It's not possible
  to use an enum inside itself (eg. to make a tree data structure).  It
  also doesn't properly calculate the enum size, because that will require
  having the target architecture info.</p>
</li>
<li>
<p>Garbage collection has been added using the Boehm-Demers-Weiser
  Conservative C Garbage Collector.  It is possible to compile without
  the garbage collector by using the <code>--no-gc</code> command line argument.</p>
</li>
<li>
<p>Traits have finally been added.  They currently are limited to one
  trait constraint per type variable, but I will hopefully add
  trait depedencies/inheritence soon</p>
</li>
</ul>
<p>I'd be happy to hear of any additional features ideas or suggestions, if
you'd like to leave them under "Issues" on github.</p><hr>
<a name="download"></a>
<h3>Get the Source</h3>
<a href="https://github.com/transistorfet/molten">https://github.com/transistorfet/molten</a><br><br>
Or clone with:<pre><code>git clone git@github.com:transistorfet/molten</code></pre>

    </div>
    <div id="footer">
        <hr>
        Made with <a href="../../generate.py">Python</a>
        <div class="email">trans@jabberwocky.ca</div>
    </div>
</div>
</body>
</html>

